{"/dev/web/be/jsframework/1_rest/": {
    "title": "REST",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/1_rest/",
    "body": "REST is called Representational State Transfer because it emphasizes the representation of resources and the transfer of their state between clients and servers over the HTTP protocol. Let’s break it down: Representational: This refers to the fact that resources (like data or information) on a server are represented in a specific format, such as JSON or XML, when they are transferred between client and server. These representations convey the state of the resource at a given point in time. State: It refers to the current condition or data of a resource. For example, the state of a user profile resource might include the user’s name, email, and profile picture. Transfer: This indicates the movement of these representations (and thus the state of resources) between client and server. The transfer occurs over the HTTP protocol, using methods like GET, POST, PUT, DELETE to request, create, update, or delete resources. So, REST is called Representational State Transfer because it describes the way web systems transfer the state of resources between clients and servers using standard representations and HTTP methods. REST Fancy way of saying that a server responses to CREATE, READ, UPDATE, DELETE (CRUD) requests in a standard way. REST treats URLs of the server as access points to the various resources on the server REST needs a way to perform CRUD REST uses HTTP methods (GET, POST, PUT, DELETE) to perform CRUD Server URLs as Access Points The urls below would make sense if not combined with the action (HTTP method) http://example.com/users http://example.com/users http://example.com/users/1 http://example.com/users/1 http://example.com/users/1 &lt;!-- - First two URLs acts on the entire users resource - Last three will only act on single user resource - There are only two distinct URLs - But REST uses these two unique URLs combined with action (HTTP method) to perform CRUD --&gt; Combined with the action (HTTP method): URL HTTP Method Description http://example.com/users GET Gets a list of the user resources, Acts on the entire user resources http://example.com/users POST Creates a new user resource, Acts on the entire user resources http://example.com/users/1 GET Gets a resource with the given ID, Acts on a single resource http://example.com/users/1 PUT Updates a resource with the given ID, Acts on a single resource http://example.com/users/1 DELETE Deletes a resource with the given ID, Acts on a single resource"
  },"/dev/web/be/jsframework/1_0_nodejs/": {
    "title": "1. NodeJS",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/1_0_nodejs/",
    "body": "Node.js has revolutionized server-side development, empowering developers to build scalable, high-performance web applications with JavaScript – the language of the web. In this wiki, you’ll find a wealth of resources covering a wide range of topics, from the basics of asynchronous programming and event-driven architecture to advanced techniques like building RESTful APIs, microservices, and real-time applications. Dependancies Make sure the dependency is installed in the correct place When a project’s Node.js dependencies are installed, they are added to the node_modules folder in the root directory of the project. Check the package.json file to see if the missing module is in the project’s dependencies or devDependencies. If it is not, install the dependency: npm install &lt;dependency name&gt; Remove dependency npm remove &lt;dependency name&gt; Update the dependency The issue may be caused by importing from an outdated module. To fix this, update the dependency to the latest version: npm update [&lt;pkg&gt;...] Delete and reinstall the dependencies If all else fails, you can try the following: Delete the node_modules folder: rm -rf node_modules Delete the package-lock.json file: rm -f package-lock.json Clear the Node.js cache, which may be corrupted: npm cache clean --force Reinstall the dependencies: npm install FAQ 1. Is NodeJS an application server or a web server ? Generally a node/Express server is thought of as an application server. A webserver is designed to be accessible to end-users in the browser, and handles requests (which it then passes over to Express and then back to the user.) Typically, people use nginx in the node world, though Apache is very popular too. Nginx is pretty much a built-for-you piece of software that doesn’t demand much customization. Typically, you’d just configure it to point requests to your Express server running on the same (or another) server. If you’re also serving static assets, like a compiled React app, nginx can point to those as well, and it’s typically much faster at delivering those assets than Node/Express would be. You can skip the webserver piece and just use Node/Express as the webserver directly – this is how a lot of developers work in development. But it’s easy to get a webserver set up and helps avoid some bottlenecks in production."
  },"/dev/web/be/jsframework/1_1_nvm/": {
    "title": "1.1 NVM",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/1_1_nvm/",
    "body": "https://www.freecodecamp.org/news/node-version-manager-nvm-install-guide/ What is NVM? Node Version Manager (NVM), as the name implies, is a tool for managing Node versions on your device. Different projects on your device may be using different versions of Node. Using only one version (the one installed by npm) for these different projects may not give you accurate execution results. For example, if you use a Node version of 10.0.0 for a project that uses 12.0.0, you may get some errors. And if you update the Node version to 12.0.0 with npm, and you use it for a project that uses 10.0.0, you may not get the expected experience. In fact, you would most likely get a warning that says: This project requires Node version X Instead of using npm to install and uninstall Node versions for your different projects, you can use nvm, which helps you effectively manage your node versions for each project. NVM allows you to install different versions of Node, and switch between these versions depending on the project that you’re working on via the command line. Before proceeding, uninstall Node.js if you have it installed already so that you do not have any conflicts with Node.js and nvm. NVM on windows NVM is mostly supported on Linux and Mac. It doesn’t have support for Windows. But there’s a similar tool created by coreybutler to provide an nvm experience in Windows called nvm-windows. Click on “Download Now” In the nvm-windows repository Readme, click on “Download Now!”: Install the .exe file of the latest release In the latest release (which as of the time of writing this is 1.1.9), you’ll find different assets. Click on the nvm-setup.exe asset which is the installation file for the tool: Complete the Installation Wizard Open the file that you have downloaded, and complete the installation wizard. When done, you can confirm that nvm has been installed by running: nvm -v If nvm was installed correctly, this command will show you the nvm version installed. After intallation: With nvm installed, you can now install, uninstall, and switch between different Node versions in your Windows, Linux, or Mac device. This command will install the last version of Node: nvm install latest This will install the X.Y.Z Node version. nvm install vX.Y.Z You can also make a version your default by running: nvm alias default vX.Y.Z And if you want to use a specific version at any point, you can run the following in your terminal: nvm use vA.B.C NVM makes it easier to manage multiple versions of Node.js across different projects that require different versions."
  },"/dev/web/be/jsframework/2_0_expressjs/": {
    "title": "2. ExpressJS",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/2_0_expressjs/",
    "body": "1. ExpressJS vs NodeJS NodeJS: Node JS is an open-source and cross-platform runtime environment for executing JavaScript code outside of a browser. You need to remember that Node JS is not a framework and it’s not a programming language. Most of the people are confused and understand it’s a framework or a programming language. We often use Node.js for building back-end services like APIs like Web App or Mobile App. It’s used in production by large companies such as Paypal, Uber, Netflix, Walmart, and so on. ExpressJS: Express is a small framework that sits on top of Node JS’s web server functionality to simplify its APIs and add helpful new features. It makes it easier to organize your application’s functionality with middleware and routing. It adds helpful utilities to Node JS’s HTTP objects. It facilitates the rendering of dynamic HTTP objects. Node JS is a platform for building i/o applications that are server-side event-driven and made using JavaScript. Express JS is a framework based on Node JS which is used for building web applications using approaches and principles of Node JS event-driven architecture. Feature Express JS Node JS Usage It is used to build web-apps using approaches and principles of Node JS It is used to build server-side, input-output, event-driven apps. Level of features More features than Node JS. Fewer features. Building Block It is built on Node JS It is built on Google’s V8 engine. Written in JavaScript C, C++, JavaScript Framework/Platform Framework based on Node JS Run-time platform or environment designed for server-side execution of JavaScript. Controllers Controllers are provided. Controllers are not provided. Routing Routing is provided. Routing is not provided. Middleware Uses middleware for the arrangement of functions systematically server-side. Doesn’t use such a provision. Coding time It requires less coding time. It requires more coding time. 2. npm vs Node.js Both Node.js and NPM have their own command-line interfaces. The Node.js CLI allows developers to execute JavaScript code on the server side, while the NPM CLI is used for package management tasks such as installing and updating packages. The NPM CLI is built on top of the Node.js CLI and provides additional functionality for managing packages and dependencies. 3. Environment Setup Create a folder and issue the following command inside the folder npm init -yes TIP --yes (or -y ) flag on the npm init command will populate all options with the default values automatically. Will create a package.json file inside the folder { \"name\": \"testproject\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } 3.1 Install expressjs npm install express To auto refresh on changes to the project npm install nodemon Installation of packages will append dependancy section to the package.json file ... \"dependencies\": { \"express\": \"^4.19.2\", \"nodemon\": \"^3.1.0\", } } Modify the package.json file and add two scripts (Line 07, 08) { \"name\": \"testproject\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"start\": \"node server.js\", \"devStart\": \"nodemon server.js\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"dependencies\": { \"express\": \"^4.19.2\", \"nodeman\": \"^1.1.2\" } } 3.2 Create server.js File server.js is the main file which will be executed by node. Create a server.js file const express = require('express'); const app = express() app.get('/' , function(req, res){ res.send(\"Hello World\") }); app.listen(3000, function(){ console.log('Listening on port 3000') }); 3.3 Start node server node server.js or npm run start WARNING If you start the server as above, every time the code is changed, the server needs to be restarted Start server with nodeman nodemon server.js or npm run devStart Restarting of the server is not required every time the code is changed."
  },"/dev/web/be/jsframework/2_1_pug/": {
    "title": "2.1 Pug",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/2_1_pug/",
    "body": "1. Introduction As web designers or developers, we likely all have to write our fair share of HTML. And while this is not the most difficult task, it can often feel a little boring or repetitive. This is where the Pug HTML preprocessor comes in. HTML is also static, which means that if you want to display dynamic data (fetched from an API, for example), you invariably end up with a mishmash of HTML stings inside JavaScript. This can be a nightmare to debug and to maintain. Pug is a template engine for Node and for the browser. It compiles to HTML and has a simplified syntax, which can make you more productive and your code more readable. Pug makes it easy both to write reusable HTML, as well as to render data pulled from a database or API. 1.1 History It’s also worth noting that Pug used to be called Jade until it was forced to change its name due to a trademark claim in 2015. The name change took effect with version 2.0. 1.2 What is pug used for A template engine is a program which is responsible for compiling a template (that can be written using any one of a number of languages) into HTML. The template engine will normally receive data from an external source, which it will inject into the template it’s compiling. This is illustrated by the following diagram. 2. Example Create a file hello.pug and place it in .\\views folder testNodeProject/ |-- views/ | |-- hello.pug |-- server.js |-- package.json In server.js set the view engine to pug const express = require('express'); const app = express() // Set the view engine app.set( 'view engine', 'pug' ); // Set handler for the root '/' app.get('/', (req, res) =&gt; { res.render('hello', {theTitle: 'This is the Title'}); // this will look for the file 'hello.pug' in './views' folder // second parameter to render(...) method is optional }); Content for hello.pug doctype html html(lang='en') head title Hello, World! #{theTitle || \"Default Value\"} //- if `theTitle` parameter is not defined when //- rending `hello.pug` use the default value \"Default Value\" body h1 Hello, World! div.remark p Pug rocks! Rendered output, when http://localhost:3000/ is accessed &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;Hello, World! This is the Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello, World!&lt;/h1&gt; &lt;div class=\"remark\"&gt; &lt;p&gt;Pug rocks!!&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3. DOCTYPE You can use Pug to generate a number of document type declarations. For example doctype html will compile to &lt;!DOCTYPE html&gt;, the standard HTML5 doctype, whereas doctype strict will give us &lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;. Pug will do its best to ensure that its output is valid for the document type. 4. Tags As mentioned, Pug doesn’t have any closing tags and relies on indentation for nesting. This might take a small amount of getting used to, but once you do, it makes for clean and readable code. By way of an example: nav navbar-default div h1 My Website! ul li a Home li a Page 1 li a Page 2 input Rendered output &lt;nav&gt; &lt;div&gt; &lt;h1&gt;My Website!&lt;/h1&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;&lt;a&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Page 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Page 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;input/&gt; &lt;/nav&gt; TIP Notice that Pug is smart enough to close any self-closing tags (such as the &lt;input /&gt; element) for us. 5. Classes, IDs and Attributes Classes and IDs are expressed using a .className and #IDname notation. For example: nav#navbar-default div.container-fluid h1.navbar-header My Website! Pug also offers us a handy shortcut. If no tag is specified, it will assume a &lt;div&gt; element: nav#navbar-default .container-fluid h1.navbar-header My Website! Both of these compile to: &lt;nav id=\"navbar-default\"&gt; &lt;div class=\"container-fluid\"&gt; &lt;h1 class=\"navbar-header\"&gt;My Website!&lt;/h1&gt; &lt;/div&gt; &lt;/nav&gt; 5.1 Attributes are added using brackets: ul li a(href='/') Home li a(href='/page-1') Page 1 li a(href='/page-2') Page 2 input.search( type='text' name='search' placeholder='Enter a search term...' ) This results in the following: &lt;ul&gt; &lt;li&gt;&lt;a href=\"/\"&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/page-1\"&gt;Page 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"/page-2\"&gt;Page 2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;input class=\"search\" type=\"text\" name=\"search\" placeholder=\"Enter a search term...\"/&gt;"
  },"/dev/web/be/jsframework/2_2_ejs/": {
    "title": "2.2 EJS",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/2_2_ejs/",
    "body": "1. Introduction EJS (Embedded JavaScript Templating) is a simple templating language that lets you generate HTML markup with plain JavaScript. Features Use plain JavaScript: Unlike pug, ejs uses JS! Fast development time: Don’t waste time learning complex new syntax or preprocessing data for proper rendering. Simple syntax: Just write JavaScript that emits the HTML you want, and get the job done! Speedy execution: We all know how fast V8 and the other JavaScript runtimes have gotten. EJS caches the intermediate JS functions for fast execution. Easy debugging: It’s easy to debug EJS errors: your errors are plain JavaScript exceptions, with template line-numbers included. Active development: EJS has a large community of active users, and the library is under active development. We’re happy to answer your questions or give you help. WARNING If you give end-users unfettered access (ref below) to the EJS render method, you are using EJS in an inherently un-secure way. Please do not report security issues that stem from doing that. EJS is effectively a JavaScript runtime. Its entire job is to execute JavaScript. If you run the EJS render method without checking the inputs yourself, you are responsible for the results. app.get('/', (req, res) =&gt; { res.render('index', req.query); }); 2. Example Create a file hello.ejs and place it in .\\views folder testNodeProject/ |-- views/ | |-- hello.ejs |-- server.js |-- package.json In server.js set the view engine to ejs const express = require('express'); const app = express() // Set the view engine app.set( 'view engine', 'ejs' ); // Set handler for the root '/' app.get('/', (req, res) =&gt; { res.render('hello', {theTitle: 'This is the Title'}); // this will look for the file 'hello.ejs' in './views' folder // second parameter to render(...) method is optional }); Content for hello.ejs &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;Hello World! &lt;%= locals.theTitle || \"Default Value\" %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;div class=\"remark\"&gt; &lt;p&gt;EJS rocks!!&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; It is important to use locals.theTitle instead of theTitle in the .ejs file above since the page will report an error if the parameter is not defined during the call to res.render(...) method. In contrast, locals dictionary will always be defined internally when called res.render(...) method. if a parameter (i.e. theTitle) is not defined, locals.theTitle will simply return nothing. Rendered output, when http://localhost:3000/ is accessed &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;title&gt;Hello World! This is the Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hello World This is the Title &lt;/body&gt; &lt;/html&gt; 3. Control Flow Statements Similar to JavaScript, EJS provides a syntax for using conditional logic within your HTML templates. Following demonstrate practical examples of using conditional statements with the EJS template 3.1 Conditional Statements Below is an example of using a if conditional statement in ejs In ./views/index.ejs CORRECT ERROR &lt;% if(true){ %&gt; &lt;h1&gt;foo&lt;/h1&gt; &lt;% } else { %&gt; &lt;h1&gt;bar&lt;/h1&gt; &lt;% } %&gt; Line 3: } else { must be on the same line &lt;% if(true){ %&gt; &lt;h1&gt;foo&lt;/h1&gt; &lt;% } %&gt; &lt;% else { %&gt; &lt;h1&gt;bar&lt;/h1&gt; &lt;% } %&gt; Line 3 and 4 must be on the same line. 3.2 Looping Statements Below is an example of using a for loop statement in ejs In server.js const express = require('express'); const app = express() // Set the view engine app.set( 'view engine', 'ejs' ); // Set handler for the root '/' app.get('/', (req, res) =&gt; { res.render('index', { data: [ { id: 1, name: \"bob\" }, { id: 2, name: \"john\" }, { id: 3, name: \"jake\" }, ] }); }); In ./views/index.ejs &lt;table&gt; &lt;% for(var i=0; i &lt; data.length; i++) { %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= data[i].id %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= data[i].name %&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% } %&gt; &lt;/table&gt; Rendered output, when http://localhost:3000/ is accessed &lt;table&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;bob&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;john&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;jake&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;"
  },"/dev/web/be/jsframework/2_3_mongoose/": {
    "title": "2.2 Mongoose",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/2_3_mongoose/",
    "body": "Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js. It manages relationships between data, provides schema validation, and is used to translate between objects in code and the representation of those objects in MongoDB. Installation npm i mongoose Connect to mongodb Create a file server.js const mongoose = require('mongoose') const dbUrl = \"&lt;URI&gt;\" // Async function mongoose.connect(dbUrl) .then(() =&gt; console.log('Connected to MongoDB')) .catch(err =&gt; console.error('Could not connect to MongoDB', err)); /*&lt;URI&gt; field ============ if mongodb is locally installed use mongodb://localhost:port/&lt;database_name&gt; if mongodb is from mongo atlas cloud mongodb+srv://&lt;username&gt;:&lt;password&gt;@cluster0.svo1s8u.mongodb.net/&lt;database_name&gt;?retryWrites=true&amp;w=majority&amp;appName=Cluster0 */ 1. Create a Schema A schema is a JSON object that defines the structure and contents of your data. A Mongoose model is a wrapper on the Mongoose schema. A Mongoose schema defines the structure of the document, default values, validators, etc., whereas a Mongoose model provides an interface to the database for creating, querying, updating, deleting records, etc 1.1 Simple Schema Create a file Post.js const postSchema = new mongoose.Schema({ title: String, author: String, tag: [ String ], /* list of strings */ date: {type: Date, default: Date.now} }); module.exports = mongoose.model(\"Post\", userSchema); 1.2 Complex Schema Create a file User.js const mongoose = require('mongoose'); const addressSchema = new new mongoose.Schema({ street: String, city: String }); const userSchema = new mongoose.Schema({ name: { type: String, required: true, lowercase: true, minLength: 1 /* Can put more properties */ }, age: { type: Number, min: 1, max: 100, /* for custom validator */ validate: { validator: v =&gt; v % 2 == 0, message: props =&gt; `${props.value} is not an even number` } }, email: String, createdAt: { type: Date, immutable: true, // default: new Date() // above will give you a static value i.e. default: 5 (same for all objects) default: () =&gt; Date.now(), /* new value every time a object it created. i.e. current date */ } updatedAt: Date bestFriend: mongoose.SchemaTypes.ObjectId, bestFriend2: { type: mongoose.SchemaTypes.ObjectId, ref: \"User\" /* tells mongodb, what type the model objectId refers to */ } hobbies: [String], address: { street: String, city: String }, address2: addressSchema /* alternative to address */ }); 1.3 Create a Model In User.js module.exports = mongoose.model(\"User\", userSchema); /* exports the model so that other js files can use it */ // Alternatively: Can export the schema // module.exports = userSchema; // // In this case, the files which require `User.js` should create a .model() // i.e. In server.js // const userSchema = require('./User') // const User = mongoose.model(\"User\", userSchema); // You can also export multiple schemas/models via export // module.exports = [ // mongoose.model(\"User\", userSchema), // mongoose.model(\"Person\", userSchema) // ] // // In server.js // const UserModels = require('./User') // UserModel[0] // User Model // UserModel[1] // Person Model User = mongoose.model(\"User\", userSchema) The first argument is the singular name of the collection your model is for. Mongoose automatically looks for the plural, lowercased version of your model name in its collections. Thus, for the example above, the model User is for the users collection in the database. The model Person is for the persons collection in the database. TIP The .model() function makes a copy of schema. Make sure that you’ve added everything you want to schema, including hooks, before calling .model()! Special Note: module.exports = mongoose.model(\"User\", userSchema, \"persons\"); If the third parameter is defined, User model data will stored in collection specified in the third param. i.e. persons collection 1.4 Creating a Collection By default, mongoose.model(\"User\", userSchema); will create a collection users once a user object is saved(). In case the collection needs to be created without a user object: In server.js const User = require('./User') User.createCollection(); 1.5 Use the Model In server.js const mongoose = require('mongoose') mongoose.connect(\"&lt;URI&gt;\") const User = require('./User') User.&lt;method&gt;(...) /* can us methods from the user class */ User.findOne(...); User.findMany(...); User.updateOne(...); User.updateMany(...); 2. Create a User In server.js const mongoose = require('mongoose') const User = require('./User') mongoose.connect(\"&lt;URI&gt;\") /* creating a user */{name: \"Kyle\", age: 26} const user = new User() /* save it into the database */ /* this is an async function */ user.save().then(() =&gt; console.log(\"User Saved\")) to avoid using then(), create a async function alternatively const mongoose = require('mongoose') const User = require('./User') mongoose.connect(\"&lt;URI&gt;\") run() async function run() { /* creating a user */ const user = new User({name: \"Kyle\", age: 26}) /* save it into the database */ await user.save(); /* or, following creates a user and saves in db */ // const user = await User.create({name: \"Kyle\", age: 26}) console.log(\"User Saved\"); consle.log(user); } Console output: { name: \"Kyle\", age: 26, _id: new ObjectId(\"61855c3d736483eaef556c5c\"), /* unique id */ __v: 0 /* for internal versioning */ } Note that user.save() will create a collection users and store the data of user object (document) as a json. Creating a user with multiple fields ... run() async function run() { try { /* errors, i.e wrong value type for the field */ const user = await User.create({ name: \"Kyle\", age: 26, hobbies: [\"Weight Lifting\", \"Bowling\"], address: { street: \"Main St\", } }); } catch (e) { console.log(e.message); // console.log(e.errors.age); } console.log(\"User Updated\"); } 3. Update User In server.js ... run(); async function run() { try { const user = await User.create({name: \"Kyle\", age: 26}) user.name = \"Sally\"; await user.save(); console.log(\"User Updated\"); console.log(user); } catch (e) { console.log(e.message); } } WARNING User.findbyIdAndUpdate() or .updateOne() or .updateMany() or etc, will not run field validations defined in the schema. Use User.findById().save() instead! ... run(); async function run() { try { const user = await User.findById(&lt;object_id&gt;); user.name = \"Sally\"; await user.save(); console.log(\"User Updated\"); console.log(user); } catch (e) { console.log(e.message); } } 4. Find a User ... run() async function run() { try { const user = await User.find({name: \"Kyle\"}); // All users with the name Kyle console.log(user) } catch (e) { console.log(e.message); } } 4.1 where(…) Method ... run() async function run() { try { const user = await User.where(\"name\").equals(\"Kyle\"); const user = await User.where(\"age\").gt(\"12\"); // greater than 12 (notice \"12\" is a numerical string) // Chaining const user = await User.where(\"age\").gt(\"12\").where(\"name\").equals(\"Kyle\"); /* Return only 2 users */ const user = await User.where(\"age\").gt(\"12\").limit(2); // Select only the \"age\" field, equivalent ot SELECT in SQL const user = await User.where(\"age\").gt(\"12\").select(\"age\") console.log(user[0]) } catch (e) { console.log(e.message); } } 4.2 Updating a Reference Field ... run() async function run() { try { // Select only the \"age\" field, equivalent ot SELECT in SQL const user = await User.where(\"name\").equals(\"Kyle\").limit(1) user[0].bestFriend = '61855c3d736483eaefcddecfef'; user[0].bestFriend2 = '61855c3d736483eaefffffccff'; await user[0].save(); console.log(user[0]) } catch (e) { console.log(e.message); } } populate() method ... run() async function run() { try { const user = await User..where(\"name\").equals(\"Kyle\") .populate(\"bestFriend\") .limit(1) /* populate(...) \"bestFriend\" field ============================== Instead of the \"bestFriend\" field is just being an id, populate the \"bestFriend\" field with teh actual data of the best friend object including all the fields. Since join in mongodb are not the best thing to do, populate() is a good alternative. */ console.log(user[0]) } catch (e) { console.log(e.message); } } 5. Delete ... run() async function run() { try { const stat = await User.deleteOne({name: \"Kyle\"}); // All users with the name Kyle console.log(stat) } catch (e) { console.log(e.message); } } output { deletedCount: 1 } 5.1 Cascade on Delete Relationships are an important part of any data design. Relational databases use primary and foreign key concepts to form those relationships when normalizing the data schema. Using those concepts, it allows a “cascading’’ delete, which means a primary key parent delete will delete the related siblings. MongoDB allows you to form relationships in different ways—for example, by embedding documents or arrays inside a parent document. This allows the document to contain all of its relationships within itself and therefore it does the cascading delete out of the box. Consider the following example between a user and the assigned tasks of the user: { userId : \"abcd\", username : \"user1@example.com\" Tasks : [ { taskId : 1, Details : [\"write\",\"print\" , \"delete\"] }, { taskId : 1, Details : [\"clean\",\"cook\" , \"eat\"] }] } However, in some design cases, we will want to separate the data of the relationship into Parent and Sibling collections—for example, games collection holding data for a specific game including ids referencing a quests collection holding a per game quest. As amount of quest data per game can be large and complex, we’d rather not embed it in games but reference: Games collection { _id: ObjectId(\"60f950794a61939b6aac12a4\"), userId: 'xxx', gameId: 'abcd-wxyz', gameName: 'Crash', quests: [ { startTime: ISODate(\"2021-01-01T22:00:00.000Z\"), questId: ObjectId(\"60f94b7beb7f78709b97b5f3\") }, { questId: ObjectId(\"60f94bbfeb7f78709b97b5f4\"), startTime: ISODate(\"2021-01-02T02:00:00.000Z\") } ] } Each game has a quest array with a start time of this quest and a reference to the quests collection where the quest data reside. Quests collection { _id: ObjectId(\"60f94bbfeb7f78709b97b5f4\"), questName: 'War of fruits ', userId: 'xxx', details: { lastModified: ISODate(\"2021-01-01T23:00:00.000Z\"), currentState: 'in-progress' }, progressRounds: [ 'failed', 'failed', 'in-progress' ] }, { _id: ObjectId(\"60f94b7beb7f78709b97b5f3\"), questName: 'War of vegetable ', userId: 'xxx', details: { lastModified: ISODate(\"2021-01-01T22:00:00.000Z\"), currentState: 'failed' }, progressRounds: [ 'failed', 'failed', 'failed' ] } When a game gets deleted, we would like to purge the relevant quests in a cascading delete. This is where the Preimage trigger feature comes into play. 5.2 Preimage Trigger Option The Preimage option allows the trigger function to receive a snapshot of the deleted/modified document just before the change that triggered the function. This feature is enabled by enriching the oplog of the underlying replica set to store this snapshot as part of the change. In our case, we will use this feature to capture the parent deleted document full snapshot (games) and delete the related relationship documents in the sibling collection (quests). 5.2.1 Building the Trigger When we define the database trigger, we will point it to the relevant cluster and parent namespace to monitor and trigger when a document is deleted—in our case, GamesDB.games. To enable the Preimage feature, we will toggle Document Preimage to ON and specify our function to handle the cascade delete logic. 5.2.2 deleteCascadingQuests - Function exports = async function(changeEvent) { // Get deleted document preImage using \"fullDocumentBeforeChange\" var deletedDocument = changeEvent.fullDocumentBeforeChange; // Get sibling collection \"quests\" const quests = context.services.get(\"mongodb-atlas\").db(\"GamesDB\").collection(\"quests\"); // Delete all relevant quest documents. deletedDocument.quests.map( async (quest) =&gt; { await quests.deleteOne({_id : quest.questId}); }) }; As you can see, the function gets the fully deleted games document present in changeEvent.fullDocumentBeforeChange and iterates over the quests array. For each of those array elements, the function runs a “deleteOne” on the quests collection to delete the relevant quests documents. 5.2.3 Deleting the Parent Document Now let’s put our trigger to the test by deleting the game from the games collection:"
  },"/dev/web/be/jsframework/2_4_routes/": {
    "title": "2.4 Routes",
    "keywords": "jsframework",
    "url": "/dev/web/be/jsframework/2_4_routes/",
    "body": "Content coming soon"
  },"/dev/web/be/phpframework/1_laravel/": {
    "title": "1. Laravel",
    "keywords": "phpframework",
    "url": "/dev/web/be/phpframework/1_laravel/",
    "body": "Welcome to the Laravel Wiki, your comprehensive guide to mastering one of the most popular PHP frameworks for web development. Whether you’re a seasoned developer looking to streamline your workflow or a newcomer eager to dive into the world of Laravel, this wiki is your go-to resource for all things Laravel. Laravel has earned its reputation for its elegant syntax, developer-friendly features, and robust ecosystem, making it the framework of choice for building modern, scalable web applications. In this wiki, you’ll find a wealth of resources covering everything from the basics of MVC architecture and routing to advanced topics like database migrations, authentication, and API development. Content is Coming Soon…"
  },"/dev/web/be/phpframework/2_cakephp/": {
    "title": "2. CakePhP",
    "keywords": "phpframework",
    "url": "/dev/web/be/phpframework/2_cakephp/",
    "body": "Welcome to the CakePHP Wiki, your ultimate resource for mastering one of the most powerful and elegant PHP frameworks available today. Whether you’re a seasoned developer seeking to streamline your workflow or a newcomer eager to harness the power of CakePHP for your projects, this wiki is your comprehensive guide to all things CakePHP. CakePHP is renowned for its simplicity, flexibility, and efficiency, enabling developers to rapidly build robust web applications with minimal boilerplate code. In this wiki, you’ll find a wealth of resources covering everything from the basics of MVC architecture and routing to advanced topics like database interactions, authentication, and security best practices. Content is Coming Soon…"
  },"/dev/web/be/pythonframework/1_django/": {
    "title": "1. Django",
    "keywords": "pythonframework",
    "url": "/dev/web/be/pythonframework/1_django/",
    "body": "Welcome to the Django Wiki, your comprehensive resource for mastering one of the most powerful and versatile web frameworks for Python. Whether you’re a seasoned developer looking to streamline your web development process or a newcomer eager to dive into the world of Django, this wiki is your go-to source for all things Django. Django is renowned for its “batteries-included” philosophy, providing developers with a robust set of tools and libraries to build web applications quickly and efficiently. In this wiki, you’ll find a wealth of resources covering everything from the basics of Django’s MTV (Model-Template-View) architecture and URL routing to advanced topics such as database migrations, authentication, and deployment. Content is Coming Soon…"
  },"/dev/web/be/pythonframework/2_adv-django/": {
    "title": "1.1. Advance Django",
    "keywords": "pythonframework",
    "url": "/dev/web/be/pythonframework/2_adv-django/",
    "body": "Welcome to the Django Wiki, your comprehensive resource for mastering one of the most powerful and versatile web frameworks for Python. Whether you’re a seasoned developer looking to streamline your web development process or a newcomer eager to dive into the world of Django, this wiki is your go-to source for all things Django. Django is renowned for its “batteries-included” philosophy, providing developers with a robust set of tools and libraries to build web applications quickly and efficiently. In this wiki, you’ll find a wealth of resources covering everything from the basics of Django’s MTV (Model-Template-View) architecture and URL routing to advanced topics such as database migrations, authentication, and deployment. Content is Coming Soon…"
  }}
