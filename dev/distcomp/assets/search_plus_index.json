{"/dev/distcomp/c_sharp/1_cs_1_fundamentals/": {
    "title": "1. Fundamentals",
    "keywords": "c_sharp",
    "url": "/dev/distcomp/c_sharp/1_cs_1_fundamentals/",
    "body": "1. Creating a DLL (Dynamic Link Library) A DLL (Dynamic Link Library) is a file that contains code and data that can be used by multiple programs simultaneously. It helps in modularizing applications and reduces memory and disk space usage since the code can be shared. DLLs are commonly used in the Windows operating system for providing reusable functions, procedures, and data structures. Certainly! Let’s go through an example of creating a simple DLL in C# using Visual Studio. Example: Creating a C# DLL We’ll create a DLL that contains a class MathLibrary with a method Add that adds two integers. 1. Create a New Project Open Visual Studio. Go to File &gt; New &gt; Project.... In the “Create a new project” dialog, search for \"Class Library\" and select “Class Library” under the C# language. Name the project MathLibrary and choose a location. Click Create. 2. Write the Code Visual Studio will create a default class file named Class1.cs. Rename this file to MathLibrary.cs. Modify the contents of the MathLibrary.cs file: using System; namespace MathLibrary { public class MathOperations { public int Add(int a, int b) { return a + b; } public int Subtract(int a, int b) { return a - b; } } } This example defines a class MathOperations within the MathLibrary namespace. The class has two methods: Add and Subtract. 3. Build the DLL Save your changes. Go to Build &gt; Build Solution (or press Ctrl+Shift+B). Visual Studio will compile the code and generate a DLL file. The DLL will be located in the bin\\Debug\\net6.0 (or similar) directory within your project folder, depending on the .NET version you’re targeting. 4. Using the DLL in Another Project To use this DLL in another project: Create a new Console Application (or any other type of application): Go to File &gt; New &gt; Project.... Select “Console App” under C# and name it MathClient. Click Create. Add a Reference to the DLL: In the Solution Explorer, right-click on the MathClient project and select Add &gt; Reference.... In the Reference Manager, select Browse on the left side, then click the Browse... button. Navigate to the MathLibrary.dll file you created, typically found in the bin\\Debug\\net6.0 folder of the MathLibrary project. Select the DLL and click Add. Use the DLL in the Console Application: In the Program.cs file of the MathClient project, add the following code: using System; using MathLibrary; namespace MathClient { class Program { static void Main(string[] args) { MathOperations math = new MathOperations(); int sum = math.Add(5, 3); int difference = math.Subtract(5, 3); Console.WriteLine($\"Sum: {sum}\"); Console.WriteLine($\"Difference: {difference}\"); } } } This code creates an instance of the MathOperations class from the MathLibrary DLL and calls its methods. 5. Run the Application Set the MathClient project as the startup project by right-clicking on it in Solution Explorer and selecting Set as StartUp Project. Run the application (press F5). You should see the output: Sum: 8 Difference: 2"
  },"/dev/distcomp/c_sharp/1_cs_2_advance/": {
    "title": "2. Advance",
    "keywords": "c_sharp",
    "url": "/dev/distcomp/c_sharp/1_cs_2_advance/",
    "body": "2.1 Data Annotations Declare Custom Attribute [System.AttributeUsage(System.AttributeTargets.Class)] public class Display : System.Attribute { private string _name; public Display(string name) { _name = name; } public string GetName() { return _name; } } Example of use [Display(\"My Class Name\")] public class MyClass { // ... } Data annotations can be used on both properties and classes. Example of reading attribute public static string GetDisplayAttributeValue() { System.Attribute[] attrs = System.Attribute.GetCustomAttributes(typeof(MyClass)); foreach (System.Attribute attr in attrs) { var displayAttribute as Display; if (displayAttribute == null) continue; return displayAttribute.GetName(); } // throw not found exception or just return string.Empty } Alternative method to read an attribute // write a static function like this: public static string GetDisplayName&lt;TModel, TProperty&gt;(this TModel model, Expression&lt;Func&lt;TModel, TProperty&gt;&gt; expression) { return ModelMetadata.FromLambdaExpression&lt;TModel, TProperty&gt;(expression, new ViewDataDictionary&lt;TModel&gt;(model)).DisplayName; } // use the function: string name = GetDisplayName(Model, m =&gt; m.Prop);"
  },"/dev/distcomp/wcf/1_dc_1_fundamentals/": {
    "title": "1. Fundamentals",
    "keywords": "wcf",
    "url": "/dev/distcomp/wcf/1_dc_1_fundamentals/",
    "body": "1. Windows Communication Foundation Windows Communication Foundation (WCF) is a framework developed by Microsoft for building service-oriented applications. It allows developers to build secure, reliable, and scalable distributed systems by providing a unified programming model for building and deploying networked services. 1.1 Key Features of WCF 1. Interoperability: WCF is designed to interoperate with services built on other platforms, thanks to its support for various industry standards like SOAP, WS-*, and REST. 2. Service-Oriented Architecture (SOA): WCF supports SOA principles, making it easier to create loosely coupled services that can be composed and orchestrated into more complex workflows. 3. Multiple Transport Protocols: WCF supports multiple communication protocols, including HTTP, TCP, MSMQ, and named pipes. This flexibility allows developers to choose the most appropriate protocol for their application’s requirements. 4. Security: WCF provides a range of security features, including message encryption, authentication, and authorization. It supports various security standards and allows for secure communication over different protocols. 5. Extensibility: WCF is highly extensible, allowing developers to customize the runtime behavior and add new communication capabilities. 6. Reliable Messaging: WCF includes built-in support for reliable messaging, ensuring that messages are delivered even in the presence of network failures. 1.2 Importance of WCF in Distributed Computing 1. Communication Abstraction: WCF abstracts the underlying communication mechanisms, allowing developers to focus on business logic rather than the complexities of networking. This is crucial for building scalable distributed systems. 2. Interoperability: With support for standard protocols and data formats, WCF facilitates communication between services built on different platforms and technologies, making it a key tool for building interoperable distributed systems. 3. Security and Reliability: WCF provides robust security features and reliable messaging, which are critical for distributed systems that need to operate over insecure or unreliable networks. 4. Scalability: WCF’s support for different communication patterns (such as request/reply, one-way, and duplex) and its ability to host services in various environments (such as IIS, Windows Services, or self-hosted) contribute to building scalable distributed systems. 5. Flexibility and Extensibility: WCF’s flexible configuration and extensibility make it suitable for a wide range of applications, from simple web services to complex, enterprise-level distributed systems. 2. CORBA ? Common Object Request Broker Architecture (CORBA) is a standard defined by the Object Management Group (OMG) for enabling communication between objects in a distributed computing environment, regardless of the programming language in which they were written or the platforms on which they are running. CORBA achieves this by specifying a set of protocols and services that facilitate object communication and interoperability. 2.1 Key Features of CORBA 1. Object Request Broker (ORB): The core component of CORBA, the ORB, acts as a middleware that handles communication between client and server objects. It manages requests and responses, handles object references, and performs necessary data conversions. 2. Interface Definition Language (IDL): CORBA uses IDL to define the interfaces that objects expose. IDL is language-agnostic, enabling objects written in different programming languages to communicate. 3. Interoperability: CORBA supports interoperability between different platforms and languages by providing standard protocols, such as IIOP (Internet Inter-ORB Protocol). 4. Services and Facilities: CORBA provides a set of standard services (e.g., naming, event, transaction) and facilities (e.g., messaging) that support distributed object interactions. 5. Platform Independence: CORBA objects can be implemented in any language and run on any platform, as long as they conform to the CORBA standard. 2.2 Relationship Between CORBA and WCF While both CORBA and WCF serve the purpose of enabling communication in distributed systems, they come from different backgrounds and have some key differences: 1. Technology Origin and Standards: CORBA: Developed by the OMG, CORBA is a vendor-neutral, platform-independent standard designed for cross-language and cross-platform interoperability. WCF: Developed by Microsoft, WCF is a .NET framework that primarily supports interoperability within the .NET ecosystem but also adheres to industry standards like SOAP and WS-*, allowing for some level of cross-platform communication. 2. Communication Model: CORBA: Focuses on an object-oriented model where distributed objects interact by invoking methods on each other, much like local objects. WCF: Is service-oriented, focusing on the exchange of messages between services. It supports various communication patterns, including request/reply, one-way, and duplex. 3. IDL vs. Contracts: CORBA: Uses IDL to define the interface of objects in a language-agnostic way. WCF: Uses .NET interfaces and attributes to define service contracts, which are typically tied to .NET languages. 4. Interoperability: CORBA: Is inherently designed for interoperability between different languages and platforms. WCF: Can interoperate with other platforms and technologies through support for standard protocols like SOAP, but it is primarily geared towards .NET applications. 5. Security and Reliability: Both CORBA and WCF offer various security and reliability features, though WCF has more built-in support for modern web standards and practices. CORBA and WCF are both technologies for building distributed systems, but they are rooted in different ecosystems and have different focuses. CORBA is a cross-platform, language-agnostic standard, while WCF is a Microsoft-centric framework with strong integration into the .NET ecosystem. Both serve to enable communication and interoperability in distributed systems, albeit with different approaches and use cases. 3. Simple Application Using WCF Creating a simple WCF (Windows Communication Foundation) application involves defining a service contract, implementing the service, hosting the service, and creating a client to consume the service. Below, I’ll walk you through a basic example where we create a simple calculator service. 1. Define the Service Contract The service contract specifies the operations that the service provides. We use the [ServiceContract] and [OperationContract] attributes to define the contract. using System.ServiceModel; [ServiceContract] public interface ICalculator { [OperationContract] double Add(double a, double b); [OperationContract] double Subtract(double a, double b); } 2. Implement the Service Implement the service contract by creating a class that implements the interface. public class CalculatorService : ICalculator { public double Add(double a, double b) { return a + b; } public double Subtract(double a, double b) { return a - b; } } 3. Host the Service The service can be hosted in various environments like IIS, Windows Services, or a console application. For simplicity, we’ll use a console application. using System; using System.ServiceModel; class Program { static void Main(string[] args) { // Define the base address for the service Uri baseAddress = new Uri(\"http://localhost:8080/CalculatorService\"); // Create the ServiceHost using (ServiceHost host = new ServiceHost(typeof(CalculatorService), baseAddress)) { // Open the host host.Open(); Console.WriteLine(\"Service is running...\"); Console.WriteLine(\"Press Enter to exit.\"); Console.ReadLine(); } } } 4. Configure the Service Add configuration details in the App.config file. This includes the service, endpoint, binding, and behavior. &lt;configuration&gt; &lt;system.serviceModel&gt; &lt;services&gt; &lt;service name=\"Namespace.CalculatorService\"&gt; &lt;endpoint address=\"\" binding=\"basicHttpBinding\" contract=\"Namespace.ICalculator\" /&gt; &lt;host&gt; &lt;baseAddresses&gt; &lt;add baseAddress=\"http://localhost:8080/CalculatorService\"/&gt; &lt;/baseAddresses&gt; &lt;/host&gt; &lt;/service&gt; &lt;/services&gt; &lt;behaviors&gt; &lt;serviceBehaviors&gt; &lt;behavior&gt; &lt;serviceMetadata httpGetEnabled=\"true\" /&gt; &lt;serviceDebug includeExceptionDetailInFaults=\"false\" /&gt; &lt;/behavior&gt; &lt;/serviceBehaviors&gt; &lt;/behaviors&gt; &lt;/system.serviceModel&gt; &lt;/configuration&gt; Replace Namespace with the appropriate namespace for your service. 5. Create a Client to Consume the Service To consume the service, you can create a client application. For simplicity, we’ll also use a console application. using System; using System.ServiceModel; class Program { static void Main(string[] args) { // Define the service endpoint string baseAddress = \"http://localhost:8080/CalculatorService\"; // Create the channel factory ChannelFactory&lt;ICalculator&gt; factory = new ChannelFactory&lt;ICalculator&gt;( new BasicHttpBinding(), new EndpointAddress(baseAddress) ); // Create the channel ICalculator calculator = factory.CreateChannel(); // Use the service double result = calculator.Add(1, 2); Console.WriteLine($\"1 + 2 = {result}\"); result = calculator.Subtract(5, 3); Console.WriteLine($\"5 - 3 = {result}\"); // Close the channel ((IClientChannel)calculator).Close(); factory.Close(); } } 6. Run the Applications Run the Service Host: Start the console application that hosts the WCF service. Run the Client: Start the console application that consumes the service. When the client runs, it should display the results of the operations provided by the CalculatorService. This example demonstrates a basic setup for a WCF application. In real-world applications, you may need to consider additional aspects like security, error handling, and more complex configurations. Alternative to Step 4 If you prefer to configure the WCF service and client entirely in code without modifying the App.config file, you can do so by setting up the ServiceHost and ChannelFactory programmatically. Here’s how you can implement it: 1. Hosting the Service Programmatically In the service host application, you can set up the ServiceHost and define the binding, endpoint, and base address in code. using System; using System.ServiceModel; public class Program { public static void Main(string[] args) { // Define the base address for the service Uri baseAddress = new Uri(\"net.tcp://localhost:8080/CalculatorService\"); // Create the ServiceHost using (ServiceHost host = new ServiceHost(typeof(CalculatorService), baseAddress)) { // Create the NetTcpBinding NetTcpBinding binding = new NetTcpBinding(); // Add the service endpoint host.AddServiceEndpoint(typeof(ICalculator), binding, \"\"); // Optional: Enable metadata exchange ServiceMetadataBehavior smb = new ServiceMetadataBehavior(); smb.MetadataExporter.PolicyVersion = PolicyVersion.Policy15; host.Description.Behaviors.Add(smb); host.AddServiceEndpoint(ServiceMetadataBehavior.MexContractName, MetadataExchangeBindings.CreateMexTcpBinding(), \"mex\"); // Open the host host.Open(); Console.WriteLine(\"Service is running...\"); Console.WriteLine(\"Press Enter to exit.\"); Console.ReadLine(); // Close the host host.Close(); } } } In this code: We define the base address as \"net.tcp://localhost:8080/CalculatorService\". We create an instance of NetTcpBinding and add a service endpoint. We optionally enable metadata exchange (MEX) over TCP, which is useful for generating client proxies. 2. Creating the Client Programmatically In the client application, you can set up the ChannelFactory and create the channel programmatically. using System; using System.ServiceModel; public class Program { public static void Main(string[] args) { // Define the service endpoint string baseAddress = \"net.tcp://localhost:8080/CalculatorService\"; // Create the NetTcpBinding NetTcpBinding binding = new NetTcpBinding(); // Create the channel factory ChannelFactory&lt;ICalculator&gt; factory = new ChannelFactory&lt;ICalculator&gt;(binding, new EndpointAddress(baseAddress)); // Create the channel ICalculator calculator = factory.CreateChannel(); // Use the service double result = calculator.Add(1, 2); Console.WriteLine($\"1 + 2 = {result}\"); result = calculator.Subtract(5, 3); Console.WriteLine($\"5 - 3 = {result}\"); // Close the channel ((IClientChannel)calculator).Close(); factory.Close(); } } In this code: We define the base address and create an instance of NetTcpBinding. We create a ChannelFactory with the binding and endpoint address. We create the channel and use the service methods. This approach eliminates the need for configuration files by specifying all settings programmatically. This can be beneficial in scenarios where dynamic configuration is required or where configuration files are not practical. However, using code for configuration can make it harder to change settings without recompiling the application."
  },"/dev/distcomp/wcf/1_dc_2_wcf/": {
    "title": "1. Fundamentals",
    "keywords": "wcf",
    "url": "/dev/distcomp/wcf/1_dc_2_wcf/",
    "body": ""
  },"/dev/distcomp/java/1_basics/": {
    "title": "1. Basics",
    "keywords": "java",
    "url": "/dev/distcomp/java/1_basics/",
    "body": ""
  }}
