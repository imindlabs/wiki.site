{"/dev/distcomp/c_sharp/1_cs_1_fundamentals/": {
    "title": "1. Fundamentals",
    "keywords": "c_sharp",
    "url": "/dev/distcomp/c_sharp/1_cs_1_fundamentals/",
    "body": "1.1 Visual Studio Project Types When working with Visual Studio 2022, you’ll notice that you can create different types of Console Applications. The two main options are: 1. Console App (.NET Framework) 2. Console App 1. Console App (.NET Framework) Target Framework: This type of project targets the .NET Framework, which is a Windows-specific framework that has been around since the early 2000s. It’s primarily used for building Windows desktop applications, Windows services, and web applications using ASP.NET Web Forms or ASP.NET MVC. Compatibility: The .NET Framework is only compatible with Windows. It is not cross-platform, meaning it won’t run natively on macOS, Linux, or other non-Windows operating systems. Libraries: You have access to the full suite of .NET Framework libraries, which include Windows-specific APIs like WPF, Windows Forms, and many legacy libraries that may not be available or fully supported in .NET Core or .NET 5/6/7/8+. Project File Format: The project file (.csproj) in .NET Framework projects is often more complex and uses an older format compared to .NET Core/.NET projects. Deployment: Applications built with .NET Framework typically require the target .NET Framework version to be installed on the machine where the application is running. 2. Console App (aka .NET 5, .NET 6, .NET 7, .NET 8, etc.) Target Framework: This type of project targets the .NET runtime (previously known as .NET Core), which is a modern, cross-platform, open-source framework. Starting from .NET 5, the name was unified to just “.NET” (e.g., .NET 5, .NET 6, .NET 7, .NET 8). Cross-Platform: Applications built using this template can run on Windows, macOS, and Linux. This is one of the key benefits of the .NET runtime compared to the .NET Framework. Performance: .NET applications tend to have better performance and smaller deployment footprints compared to .NET Framework applications due to the optimizations in the runtime and the ability to deploy as self-contained applications. Modern APIs: The .NET runtime is actively developed, and new features and APIs are added with each release. It also includes modern libraries and supports the latest C# language features more rapidly than the .NET Framework. Project File Format: The project file (.csproj) in .NET projects is simpler and uses a more streamlined, SDK-style format. This format is easier to read and manage, especially in source control systems. Deployment: You can create self-contained deployments that include the .NET runtime, so the target machine doesn’t need to have the runtime installed. This is in contrast to the .NET Framework, where the correct version of the framework must be installed on the target machine. 3. Key Differences 1. Platform Support: .NET Framework Console App: Windows-only. .NET Console App: Cross-platform (Windows, macOS, Linux). 2. Development and Deployment: .NET Framework: Requires the specific version of .NET Framework to be installed on the target machine. .NET: Can be deployed as a self-contained application, bundling the runtime with the app. 3. Project Structure: .NET Framework: Uses an older, more complex project file format. .NET: Uses a simpler, SDK-style project file. 4. API Availability: .NET Framework: Includes legacy APIs and Windows-specific libraries. .NET: Focuses on modern APIs and cross-platform development. 5. Performance: .NET Framework: May have higher memory and performance overhead compared to .NET. .NET: Generally more optimized for performance and has better support for modern hardware. 3. Which One Should You Choose? Choose Console App (.NET Framework) if**: You need to use libraries or APIs that are only available in the .NET Framework. You’re maintaining or extending a legacy application that was built on the .NET Framework. Choose Console App (.NET) if**: You want to build cross-platform applications. You need to use the latest features of C# and .NET. You are starting a new project and want to take advantage of the modern, high-performance features of the .NET runtime. You prefer a simpler and more modern project structure and tooling. 2. Creating a DLL (Dynamic Link Library) A DLL (Dynamic Link Library) is a file that contains code and data that can be used by multiple programs simultaneously. It helps in modularizing applications and reduces memory and disk space usage since the code can be shared. DLLs are commonly used in the Windows operating system for providing reusable functions, procedures, and data structures. Certainly! Let’s go through an example of creating a simple DLL in C# using Visual Studio. 2.1 Example We’ll create a DLL that contains a class MathLibrary with a method Add that adds two integers. 1. Create a New Project Open Visual Studio. Go to File &gt; New &gt; Project.... In the “Create a new project” dialog, search for \"Class Library (.Net Framework)\" and select “Class Library” under the C# language. Name the project MathLibrary and choose a location. Click Create. 2. Write the Code Visual Studio will create a default class file named Class1.cs. Rename this file to MathLibrary.cs. Modify the contents of the MathLibrary.cs file: using System; namespace MathLibrary { public class MathOperations { public int Add(int a, int b) { return a + b; } public int Subtract(int a, int b) { return a - b; } } } This example defines a class MathOperations within the MathLibrary namespace. The class has two methods: Add and Subtract. 3. Build the DLL Save your changes. Go to Build &gt; Build Solution (or press Ctrl+Shift+B). Visual Studio will compile the code and generate a DLL file. The DLL will be located in the bin\\Debug\\net6.0 (or similar) directory within your project folder, depending on the .NET version you’re targeting. 4. Using the DLL in Another Project To use this DLL in another project: Create a new Console Application (or any other type of application): Go to File &gt; New &gt; Project.... Select “Console App” under C# and name it MathClient. Click Create. Add a Reference to the DLL: In the Solution Explorer, right-click on the MathClient project and select Add &gt; Reference.... In the Reference Manager, select Browse on the left side, then click the Browse... button. Navigate to the MathLibrary.dll file you created, typically found in the bin\\Debug\\net6.0 folder of the MathLibrary project. Select the DLL and click Add. IMPORTANT Alternatively you can add the DLL project reference if the MathClient Project and the DLL project is in the same solution. This will be helpful when performing debugging the DLL projects via breakpoints Use the DLL in the Console Application: In the Program.cs file of the MathClient project, add the following code: using System; using MathLibrary; namespace MathClient { class Program { static void Main(string[] args) { MathOperations math = new MathOperations(); int sum = math.Add(5, 3); int difference = math.Subtract(5, 3); Console.WriteLine($\"Sum: {sum}\"); Console.WriteLine($\"Difference: {difference}\"); } } } This code creates an instance of the MathOperations class from the MathLibrary DLL and calls its methods. 5. Run the Application Set the MathClient project as the startup project by right-clicking on it in Solution Explorer and selecting Set as StartUp Project. Run the application (press F5). You should see the output: Sum: 8 Difference: 2"
  },"/dev/distcomp/c_sharp/1_cs_2_advance/": {
    "title": "2. Advance",
    "keywords": "c_sharp",
    "url": "/dev/distcomp/c_sharp/1_cs_2_advance/",
    "body": "2.1 Data Annotations Declare Custom Attribute [System.AttributeUsage(System.AttributeTargets.Class)] public class Display : System.Attribute { private string _name; public Display(string name) { _name = name; } public string GetName() { return _name; } } Example of use [Display(\"My Class Name\")] public class MyClass { // ... } Data annotations can be used on both properties and classes. Example of reading attribute public static string GetDisplayAttributeValue() { System.Attribute[] attrs = System.Attribute.GetCustomAttributes(typeof(MyClass)); foreach (System.Attribute attr in attrs) { var displayAttribute as Display; if (displayAttribute == null) continue; return displayAttribute.GetName(); } // throw not found exception or just return string.Empty } Alternative method to read an attribute // write a static function like this: public static string GetDisplayName&lt;TModel, TProperty&gt;(this TModel model, Expression&lt;Func&lt;TModel, TProperty&gt;&gt; expression) { return ModelMetadata.FromLambdaExpression&lt;TModel, TProperty&gt;(expression, new ViewDataDictionary&lt;TModel&gt;(model)).DisplayName; } // use the function: string name = GetDisplayName(Model, m =&gt; m.Prop); 2.2 using keyword in C# In C#, the using statement is used to ensure that resources are properly disposed of when they are no longer needed. This is particularly useful for objects that consume resources like file handles, database connections, or network connections, which need to be explicitly released. There are two primary ways to use using in C#: 1. Using with a Single Object This is the most common usage, where a single object that implements the IDisposable interface is used within a using block. When the block is exited, either normally or through an exception, the object’s Dispose method is automatically called. using (var resource = new SomeDisposableResource()) { // Use the resource here. } // resource.Dispose() is automatically called here. 2. Using with Multiple Objects (C# 8.0 and later) Starting with C# 8.0, you can declare multiple disposable objects within a single using statement. using (var resource1 = new SomeDisposableResource()) using (var resource2 = new AnotherDisposableResource()) { // Use resource1 and resource2 here. } // resource1.Dispose() and resource2.Dispose() are automatically called here. 3. Using as a Declaration (C# 8.0 and later) In C# 8.0 and later, you can also use using as a declaration without a block. The resource will be disposed at the end of the containing scope, such as a method. using var resource = new SomeDisposableResource(); // Use the resource here. // resource.Dispose() is automatically called at the end of the scope. Example with a File Stream Here is an example using using with a FileStream to read from a file: using (var stream = new FileStream(\"example.txt\", FileMode.Open)) using (var reader = new StreamReader(stream)) { string content = reader.ReadToEnd(); Console.WriteLine(content); } // Both stream and reader are disposed here. This ensures that both the FileStream and StreamReader are properly disposed of, even if an exception occurs while reading the file."
  },"/dev/distcomp/c_sharp/1_cs_3_async_task/": {
    "title": "3. Async Task",
    "keywords": "c_sharp",
    "url": "/dev/distcomp/c_sharp/1_cs_3_async_task/",
    "body": "3.1 Basics In C#, async tasks are a way to perform asynchronous operations, allowing your code to run tasks that might take some time (like I/O operations, network requests, or database queries) without blocking the main thread. This leads to more responsive applications, particularly in scenarios where you’re performing operations that would otherwise make the application appear unresponsive. 1. Key Concepts 1. async Keyword: The async keyword is used to mark a method as asynchronous. It allows the use of the await keyword inside the method, enabling asynchronous operations. An async method usually returns a Task or Task&lt;T&gt;, where T is the type of the result. If the method doesn’t return a value, it can return Task. 2. await Keyword: The await keyword is used to asynchronously wait for a Task to complete. It pauses the execution of the method until the awaited task is done, but it doesn’t block the thread. Instead, it allows the thread to continue with other work, and the execution of the async method resumes once the awaited task is completed. 3. Task and Task&lt;T&gt;: A Task represents an asynchronous operation. Task&lt;T&gt; represents an asynchronous operation that returns a value of type T. Task.Run can be used to run code in the background, off the main thread. 2. Why Use Async Tasks? 1. Improved Responsiveness: In UI applications, using async tasks can prevent the UI from freezing while waiting for long-running operations like file I/O or network requests. 2. Scalability: In server applications, async tasks allow the server to handle more requests by not blocking threads while waiting for I/O operations to complete. 3. Non-blocking Operations: Asynchronous programming allows the CPU to perform other tasks while waiting for long-running operations to finish, improving overall efficiency. In summary, async tasks in C# are a powerful tool for writing responsive, non-blocking code, particularly in scenarios involving I/O-bound or CPU-bound operations that take time to complete. 3. Example: Performing Multiple Asynchronous Operations Let’s simulate downloading data from multiple sources asynchronously. using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { Console.WriteLine(\"Starting downloads...\"); // Start multiple asynchronous tasks Task&lt;string&gt; downloadTask1 = DownloadDataAsync(\"Source 1\"); Task&lt;string&gt; downloadTask2 = DownloadDataAsync(\"Source 2\"); Task&lt;string&gt; downloadTask3 = DownloadDataAsync(\"Source 3\"); // Wait for all tasks to complete string[] results = await Task.WhenAll(downloadTask1, downloadTask2, downloadTask3); // Display the results foreach (var result in results) { Console.WriteLine(result); } Console.WriteLine(\"All downloads complete.\"); } // Simulate an asynchronous operation (e.g., downloading data) static async Task&lt;string&gt; DownloadDataAsync(string source) { // Simulate a delay (e.g., downloading data from a source) await Task.Delay(new Random().Next(1000, 3000)); // Return the downloaded data return $\"{source} download complete!\"; } } 1. Main Method: Multiple asynchronous tasks are started simultaneously: DownloadDataAsync(\"Source 1\"), DownloadDataAsync(\"Source 2\"), and DownloadDataAsync(\"Source 3\"). These tasks run concurrently, so they don’t block each other. await Task.WhenAll(downloadTask1, downloadTask2, downloadTask3); waits for all the download tasks to complete before proceeding. 2. DownloadDataAsync Method: This method simulates downloading data from a source by introducing a random delay using Task.Delay(new Random().Next(1000, 3000));. After the delay, it returns a string indicating that the download from the specific source is complete. 3. Output: The program will print “Starting downloads…” immediately. After all downloads are complete, it will print the completion messages for each source in the order they finished. Finally, it will print “All downloads complete.” This example shows how to execute multiple tasks concurrently and wait for all of them to finish, which is a common scenario when working with asynchronous code. 3.2 Task.Any(…) Task.WhenAny is a method in C# that takes in a collection of tasks and returns a task that completes when any of the provided tasks completes. This is useful when you want to perform some action as soon as the first task finishes, rather than waiting for all tasks to complete. 1. Basic Usage of Task.WhenAny using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { Console.WriteLine(\"Starting tasks...\"); // Start multiple tasks Task&lt;string&gt; task1 = Task1(); Task&lt;string&gt; task2 = Task2(); Task&lt;string&gt; task3 = Task3(); // Wait for any of the tasks to complete Task&lt;string&gt; completedTask = await Task.WhenAny(task1, task2, task3); // Get the result of the first completed task string result = await completedTask; // Console.WriteLine($\"First task completed with result: {result}\"); } static async Task&lt;string&gt; Task1() { await Task.Delay(3000); // Simulate a 3-second task return \"Task 1 complete\"; } static async Task&lt;string&gt; Task2() { await Task.Delay(2000); // Simulate a 2-second task return \"Task 2 complete\"; } static async Task&lt;string&gt; Task3() { await Task.Delay(1000); // Simulate a 1-second task return \"Task 3 complete\"; } } 1 Multiple Tasks: Three tasks (Task1, Task2, and Task3) are started simultaneously, each with different delays simulating different completion times. 2 Task.WhenAny: Task.WhenAny(task1, task2, task3) returns a task that completes when the first of the provided tasks completes. This task contains a reference to the first completed task. 3 Getting the Result: After the first task completes, await completedTask is used to get the result of that task. The program then prints which task completed first. 4 Output: Since Task3 has the shortest delay (1 second), it completes first, and the output will be: Starting tasks... First task completed with result: Task 3 complete 2. Use Cases for Task.WhenAny: 1 Fastest Response: In scenarios where you have multiple ways to achieve the same result (e.g., querying multiple servers for data), you might want to proceed with the result of the first server that responds. 2 Timeouts: You can use Task.WhenAny to implement timeouts. For example, you could create a delay task (Task.Delay) alongside your main task and proceed with whichever completes first. 3. Example: Task with Timeout using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { // Start a task that takes 5 seconds Task&lt;string&gt; longRunningTask = LongRunningOperation(); // Create a timeout task of 2 seconds Task timeoutTask = Task.Delay(2000); // Wait for either the long-running task or the timeout Task completedTask = await Task.WhenAny(longRunningTask, timeoutTask); if (completedTask == timeoutTask) { Console.WriteLine(\"Operation timed out.\"); } else { string result = await longRunningTask; Console.WriteLine($\"Operation completed: {result}\"); } } static async Task&lt;string&gt; LongRunningOperation() { await Task.Delay(5000); // Simulate a 5-second task return \"Operation complete\"; } } Timeout Scenario: In this example, Task.WhenAny is used to determine if the long-running operation finishes before the timeout. If the timeout task completes first, it prints “Operation timed out.” Otherwise, it proceeds with the result of the long-running operation. Output: Since the timeout task is shorter (2 seconds) than the long-running task (5 seconds), the program will output: Operation timed out. Task.WhenAny is a powerful tool in asynchronous programming, especially when dealing with scenarios where timing and responsiveness are critical. 4. Wait for Remaining Tasks 4.1 Wait for All Remaining Tasks Once Task.WhenAny returns the first completed task, you might still need to wait for the other tasks to finish. There are several ways to do this, depending on your specific requirements. If you want to wait for all other tasks to finish after Task.WhenAny returns, you can use Task.WhenAll to wait for the remaining tasks. Example: using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { Console.WriteLine(\"Starting tasks...\"); // Start multiple tasks Task&lt;string&gt; task1 = Task1(); Task&lt;string&gt; task2 = Task2(); Task&lt;string&gt; task3 = Task3(); // Wait for any of the tasks to complete Task&lt;string&gt; completedTask = await Task.WhenAny(task1, task2, task3); // Get the result of the first completed task string result = await completedTask; Console.WriteLine($\"First task completed with result: {result}\"); // Wait for all remaining tasks to complete await Task.WhenAll(task1, task2, task3); Console.WriteLine(\"All tasks are now completed.\"); } static async Task&lt;string&gt; Task1() { await Task.Delay(3000); // Simulate a 3-second task return \"Task 1 complete\"; } static async Task&lt;string&gt; Task2() { await Task.Delay(2000); // Simulate a 2-second task return \"Task 2 complete\"; } static async Task&lt;string&gt; Task3() { await Task.Delay(1000); // Simulate a 1-second task return \"Task 3 complete\"; } } 1 Task.WhenAny: The program waits for the first task to complete using Task.WhenAny. 2 Wait for All Tasks: After getting the result from the first completed task, await Task.WhenAll(task1, task2, task3); is used to wait for all tasks to complete. Since the first task has already completed, Task.WhenAll will immediately return for that task and only wait for the other two. 3 Output: The output will show the result of the first task that completed and then indicate that all tasks have finished: Starting tasks... First task completed with result: Task 3 complete All tasks are now completed. 4.2 Wait for Each Remaining Task Separately Alternatively, you could wait for each of the remaining tasks individually. Example: using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { Console.WriteLine(\"Starting tasks...\"); // Start multiple tasks Task&lt;string&gt; task1 = Task1(); Task&lt;string&gt; task2 = Task2(); Task&lt;string&gt; task3 = Task3(); // Wait for any of the tasks to complete Task&lt;string&gt; completedTask = await Task.WhenAny(task1, task2, task3); // Get the result of the first completed task string result = await completedTask; Console.WriteLine($\"First task completed with result: {result}\"); // Manually wait for the other tasks if (completedTask != task1) { string result1 = await task1; Console.WriteLine($\"Task 1 completed with result: {result1}\"); } if (completedTask != task2) { string result2 = await task2; Console.WriteLine($\"Task 2 completed with result: {result2}\"); } if (completedTask != task3) { string result3 = await task3; Console.WriteLine($\"Task 3 completed with result: {result3}\"); } Console.WriteLine(\"All tasks are now completed.\"); } static async Task&lt;string&gt; Task1() { await Task.Delay(3000); // Simulate a 3-second task return \"Task 1 complete\"; } static async Task&lt;string&gt; Task2() { await Task.Delay(2000); // Simulate a 2-second task return \"Task 2 complete\"; } static async Task&lt;string&gt; Task3() { await Task.Delay(1000); // Simulate a 1-second task return \"Task 3 complete\"; } } Manual Waiting: After determining which task completed first, the code manually waits for the remaining tasks to complete by checking if each task is not the one that completed first. Output: The output will indicate which task completed first and then provide the results of the other tasks as they finish: Starting tasks... First task completed with result: Task 3 complete Task 2 completed with result: Task 2 complete Task 1 completed with result: Task 1 complete All tasks are now completed. Task.WhenAny returns the first task that completes, but the other tasks are still running. You can wait for the other tasks to finish using Task.WhenAll or by individually awaiting each remaining task. This pattern is useful in scenarios where you care about the first result but also need to ensure all tasks have completed before proceeding."
  },"/dev/distcomp/wcf/1_dc_1_fundamentals/": {
    "title": "1. Fundamentals",
    "keywords": "wcf",
    "url": "/dev/distcomp/wcf/1_dc_1_fundamentals/",
    "body": "1.1 Windows Communication Foundation Windows Communication Foundation (WCF) is a framework developed by Microsoft for building service-oriented applications. It allows developers to build secure, reliable, and scalable distributed systems by providing a unified programming model for building and deploying networked services. 1 Key Features of WCF 1. Interoperability: WCF is designed to interoperate with services built on other platforms, thanks to its support for various industry standards like SOAP, WS-*, and REST. 2. Service-Oriented Architecture (SOA): WCF supports SOA principles, making it easier to create loosely coupled services that can be composed and orchestrated into more complex workflows. 3. Multiple Transport Protocols: WCF supports multiple communication protocols, including HTTP, TCP, MSMQ, and named pipes. This flexibility allows developers to choose the most appropriate protocol for their application’s requirements. 4. Security: WCF provides a range of security features, including message encryption, authentication, and authorization. It supports various security standards and allows for secure communication over different protocols. 5. Extensibility: WCF is highly extensible, allowing developers to customize the runtime behavior and add new communication capabilities. 6. Reliable Messaging: WCF includes built-in support for reliable messaging, ensuring that messages are delivered even in the presence of network failures. 2. Importance of WCF in Distributed Computing 1. Communication Abstraction: WCF abstracts the underlying communication mechanisms, allowing developers to focus on business logic rather than the complexities of networking. This is crucial for building scalable distributed systems. 2. Interoperability: With support for standard protocols and data formats, WCF facilitates communication between services built on different platforms and technologies, making it a key tool for building interoperable distributed systems. 3. Security and Reliability: WCF provides robust security features and reliable messaging, which are critical for distributed systems that need to operate over insecure or unreliable networks. 4. Scalability: WCF’s support for different communication patterns (such as request/reply, one-way, and duplex) and its ability to host services in various environments (such as IIS, Windows Services, or self-hosted) contribute to building scalable distributed systems. 5. Flexibility and Extensibility: WCF’s flexible configuration and extensibility make it suitable for a wide range of applications, from simple web services to complex, enterprise-level distributed systems. 1.2 CORBA ? Common Object Request Broker Architecture (CORBA) is a standard defined by the Object Management Group (OMG) for enabling communication between objects in a distributed computing environment, regardless of the programming language in which they were written or the platforms on which they are running. CORBA achieves this by specifying a set of protocols and services that facilitate object communication and interoperability. 1. Key Features of CORBA 1. Object Request Broker (ORB): The core component of CORBA, the ORB, acts as a middleware that handles communication between client and server objects. It manages requests and responses, handles object references, and performs necessary data conversions. 2. Interface Definition Language (IDL): CORBA uses IDL to define the interfaces that objects expose. IDL is language-agnostic, enabling objects written in different programming languages to communicate. 3. Interoperability: CORBA supports interoperability between different platforms and languages by providing standard protocols, such as IIOP (Internet Inter-ORB Protocol). 4. Services and Facilities: CORBA provides a set of standard services (e.g., naming, event, transaction) and facilities (e.g., messaging) that support distributed object interactions. 5. Platform Independence: CORBA objects can be implemented in any language and run on any platform, as long as they conform to the CORBA standard. 2. Relationship Between CORBA and WCF While both CORBA and WCF serve the purpose of enabling communication in distributed systems, they come from different backgrounds and have some key differences: 1. Technology Origin and Standards: CORBA: Developed by the OMG, CORBA is a vendor-neutral, platform-independent standard designed for cross-language and cross-platform interoperability. WCF: Developed by Microsoft, WCF is a .NET framework that primarily supports interoperability within the .NET ecosystem but also adheres to industry standards like SOAP and WS-*, allowing for some level of cross-platform communication. 2. Communication Model: CORBA: Focuses on an object-oriented model where distributed objects interact by invoking methods on each other, much like local objects. WCF: Is service-oriented, focusing on the exchange of messages between services. It supports various communication patterns, including request/reply, one-way, and duplex. 3. IDL vs. Contracts: CORBA: Uses IDL to define the interface of objects in a language-agnostic way. WCF: Uses .NET interfaces and attributes to define service contracts, which are typically tied to .NET languages. 4. Interoperability: CORBA: Is inherently designed for interoperability between different languages and platforms. WCF: Can interoperate with other platforms and technologies through support for standard protocols like SOAP, but it is primarily geared towards .NET applications. 5. Security and Reliability: Both CORBA and WCF offer various security and reliability features, though WCF has more built-in support for modern web standards and practices. CORBA and WCF are both technologies for building distributed systems, but they are rooted in different ecosystems and have different focuses. CORBA is a cross-platform, language-agnostic standard, while WCF is a Microsoft-centric framework with strong integration into the .NET ecosystem. Both serve to enable communication and interoperability in distributed systems, albeit with different approaches and use cases. 1.3 Simple Application Using WCF Creating a simple WCF (Windows Communication Foundation) application involves defining a service contract, implementing the service, hosting the service, and creating a client to consume the service. Following is the walk through of a simple calculator service. 1. Define the Service Contract Create a Visual Studio Class Library C# (.Net Framework) Project. Name the project as Interface. Add the Assembly reference for System.ServiceModel in the project. IMPORTANT Do not select the Class Library (that does not have full .Net Framework Support) which can run on all platforms (linux, mac os, windows). This will not let you add the Assembly reference System.ServiceModel The service contract specifies the operations that the service provides. We use the [ServiceContract] and [OperationContract] attributes to define the contract. using System.ServiceModel; namespace CalculatorInterface { [ServiceContract] public interface ICalculator { [OperationContract] double Add(double a, double b); [OperationContract] double Subtract(double a, double b); } } 2. Implement the Service Create a Visual Studio Console App (.Net Framework) Project. Name the project as ServerApp. Add the Assembly reference for System.ServiceModel in the project. Add the project reference to the project Interface created above. Implement the service contract by creating a class that implements the interface. using CalculatorInterface; namespace CalculatorNS { public class CalculatorService : ICalculator { public double Add(double a, double b) { return a + b; } public double Subtract(double a, double b) { return a - b; } } } 3. Host the Service In the ServerApp project, the service can be hosted in various environments like IIS, Windows Services, or a console application. For simplicity, we’ll use a console application. using System; using System.ServiceModel; public class Program { public static void Main(string[] args) { //Start the server Console.WriteLine(\"Welcome\"); var tcp = new NetTcpBinding(); // Create the ServiceHost ServiceHost host = new ServiceHost(typeof(CalculatorService)); // Bind the interface (Define the base address for the service) host.AddServiceEndpoint(typeof(ICalculator), tcp, \"net.tcp://localhost:8081/Calculator\"); // Open the host host.Open(); Console.WriteLine(\"Service is running...\"); Console.WriteLine(\"Press Enter to exit.\"); Console.ReadLine(); // Close the host host.Close(); } } In this code: We define the base address as \"net.tcp://localhost:8081/Calculator\". We create an instance of NetTcpBinding and add a service endpoint. We optionally enable metadata exchange (MEX) over TCP, which is useful for generating client proxies. 4. Creating the Client Create a Visual Studio Console App (.Net Framework) Project. Name the project as ClientApp. Add the Assembly reference for System.ServiceModel in the project. Add the project reference to the project Interface created above. using System; using System.ServiceModel; public class Program { public static void Main(string[] args) { // Define the service endpoint string baseAddress = \"net.tcp://localhost:8081/Calculator\"; // Create the NetTcpBinding NetTcpBinding binding = new NetTcpBinding(); // Create the channel factory ChannelFactory&lt;ICalculator&gt; factory = new ChannelFactory&lt;ICalculator&gt;(binding, baseAddress); // Create the channel ICalculator calculator = factory.CreateChannel(); // Use the service double result = calculator.Add(1, 2); Console.WriteLine($\"1 + 2 = {result}\"); result = calculator.Subtract(5, 3); Console.WriteLine($\"5 - 3 = {result}\"); // Close the channel ((IClientChannel)calculator).Close(); factory.Close(); Console.ReadLine(); } } In this code: We define the base address and create an instance of NetTcpBinding. We create a ChannelFactory with the binding and endpoint address. We create the channel and use the service methods. 5. Run the Applications Run the Service Host: Start the console application that hosts the WCF service. Run the Client: Start the console application that consumes the service. When the client runs, it should display the results of the operations provided by the ICalculator Interface."
  },"/dev/distcomp/wcf/1_dc_2_service_and_data_contract/": {
    "title": "2. Contracts",
    "keywords": "wcf",
    "url": "/dev/distcomp/wcf/1_dc_2_service_and_data_contract/",
    "body": "2.1 Service Contract In Windows Communication Foundation (WCF), the ServiceContract attribute is used to define a service contract. A service contract in WCF specifies the operations that a service exposes and provides a way to describe how the service can be called and interacted with by clients. 1. Key Points about ServiceContract 1. Definition of Service Interface: The ServiceContract attribute is applied to an interface, which defines the methods that the service will expose to clients. These methods must be decorated with the OperationContract attribute to be part of the service contract. [ServiceContract] public interface IMyService { [OperationContract] string SayHello(string name); } 2. Declarative Metadata: By using ServiceContract, you are providing metadata about the service that WCF uses to generate the necessary communication infrastructure, such as service endpoints, bindings, and contracts. 3. Configuration: The service contract is used in conjunction with other WCF configurations to set up how the service is hosted and how it communicates with clients. This is typically specified in configuration files or programmatically. 4. Data Contracts: To define the data types that are exchanged between the service and clients, you also use the DataContract attribute on classes and the DataMember attribute on properties or fields. 2. Example of a Service Contract Here’s a simple example of a WCF service contract: using System.ServiceModel; [ServiceContract] public interface ICalculatorService { [OperationContract] int Add(int a, int b); [OperationContract] int Subtract(int a, int b); } The ICalculatorService interface is marked with the ServiceContract attribute, indicating that it defines a WCF service contract. The Add and Subtract methods are marked with the OperationContract attribute, indicating that they are operations that clients can invoke. Implementing the Service Contract To implement this contract, you create a class that implements the interface: public class CalculatorService : ICalculatorService { public int Add(int a, int b) { return a + b; } public int Subtract(int a, int b) { return a - b; } } In this implementation, the CalculatorService class provides the logic for the operations defined in the ICalculatorService contract. 2.2 Data Contract In Windows Communication Foundation (WCF), a Data Contract is used to define the structure of data that is exchanged between a service and its clients. It specifies how data is serialized and deserialized, ensuring that both the service and client understand the format of the data being transferred. 1. Key Points about Data Contracts 1. Definition of Data Structures: A Data Contract is applied to a class or struct and describes the data that will be transferred between the service and client. You use the DataContract attribute to mark the class or struct, and DataMember attributes to specify which members of the class or struct are included in the contract. 2. Serialization: Data Contracts define how data is serialized into XML or JSON (depending on the binding) for transmission over the network. This serialization is necessary because WCF needs a standardized way to represent data for communication. 3. Consistency: Data Contracts ensure that both the service and the client use the same data format. Any changes to the data contract in the service must be compatible with the contract expected by the client to avoid communication issues. 4. Optional and Required Members: Data members in a Data Contract can be optional or required. By default, members are optional, and you can use the IsRequired property of the DataMember attribute to specify if a member is required. 2. Example of a Data Contract Here is an example of how you define a Data Contract in WCF: using System.Runtime.Serialization; [DataContract] public class Person { [DataMember] public string FirstName { get; set; } [DataMember] public string LastName { get; set; } [DataMember(IsRequired = true)] public int Age { get; set; } } In this example: The Person class is decorated with the [DataContract] attribute, indicating that it is a data contract. The FirstName, LastName, and Age properties are decorated with the [DataMember] attribute, indicating that these properties are part of the data contract and will be serialized/deserialized. 3. Using Data Contracts in Services When defining a WCF service, you can use data contracts as method parameters and return values: [ServiceContract] public interface IPersonService { [OperationContract] Person GetPersonInfo(int id); } In this service contract, the GetPersonInfo method returns a Person object, which is defined by the data contract. 4. Data Contract Considerations Versioning: If the structure of your data contract changes, you should consider how these changes might affect clients. Adding new members with default values is typically safe, but removing or renaming members can cause issues. Inheritance: Data Contracts support inheritance, allowing derived classes to be used with WCF services. Ensure that derived classes are also properly decorated with DataContract and DataMember attributes. Data Contracts play a crucial role in WCF by providing a way to define and control the structure of data exchanged between services and clients, ensuring compatibility and consistency in communication. 5. Private Members in DataContract? In WCF, private members of a class cannot be directly passed using a Data Contract. The Data Contract mechanism requires that only public members (properties or fields) be included in the serialization process. IMPORTANT In WCF Data Contracts, only public members are included in serialization. Private members must be accessed through public properties or other public interfaces if you need them to be part of the data contract. This approach ensures that the contract remains clear and manageable, while still allowing you to control the visibility and access of your data. Here’s a breakdown of why this is the case and how you can work around it: 5.1 Why Private Members Aren’t Included 1. Serialization: WCF’s serialization process relies on accessing public members to convert them into a format suitable for transmission (like XML or JSON). Private members are not accessible during serialization because they are not part of the public interface of the class. 2. Data Contract Specification: The Data Contract model is designed to be explicit about what data is serialized and deserialized. By focusing on public members, WCF ensures that only the intended data is included in the contract. 5.2 Workarounds If you need to include data that is not directly accessible through public members, you can use the following approaches: 1. Expose Data via Public Properties: Define public properties in your Data Contract class that internally access private fields. This way, you control the exposure of the data while still adhering to the Data Contract model. [DataContract] public class Person { private string _firstName; private string _lastName; [DataMember] public string FirstName { get { return _firstName; } set { _firstName = value; } } [DataMember] public string LastName { get { return _lastName; } set { _lastName = value; } } } 2. Use Data Members with Properties: You can also use properties to control the serialization of private data. Define properties with both get and set accessors for serialization, and use private fields to store the actual data. [DataContract] public class Person { [DataMember] public string FirstName { get; set; } [DataMember] public string LastName { get; set; } // Private field not exposed directly but used internally private int Age { get; set; } } 3. Custom Serialization: For more control, you can implement custom serialization logic by using IDataContractSurrogate to customize how data is serialized and deserialized. However, this is more advanced and generally not required for standard use cases. 2.3 Serializing Methods No, methods of a class do not get serialized in WCF Data Contracts. Serialization in WCF is concerned with the data that is being exchanged between the service and the client, not with the behavior or operations of the class. IMPORTANT In WCF, only public data members marked with the [DataMember] attribute are serialized. Methods of the class are not part of the serialization process, as serialization is focused on the exchange of data rather than behavior or operations. 1. What Gets Serialized 1. Data Members: Only public properties or fields that are decorated with the [DataMember] attribute in a Data Contract are included in the serialization process. These are the data elements that are transferred between the client and the service. 2. Class Structure: The class structure, including its data members, is serialized into XML or JSON format (depending on the binding) so that it can be transmitted over the network. Methods, however, are not part of this process. 2. Example of a Data Contract Here’s a simple example of a Data Contract: [DataContract] public class Person { [DataMember] public string FirstName { get; set; } [DataMember] public string LastName { get; set; } // This method will not be serialized public string GetFullName() { return $\"{FirstName} {LastName}\"; } } The FirstName and LastName properties are data members and will be serialized. The GetFullName method is a behavior of the class and will not be serialized. It is used for processing data but does not participate in the serialization process. 3. Why Methods Aren’t Serialized 1. Focus on Data: Serialization is focused on the data being exchanged, not on the operations or logic of the class. Including methods in serialization would complicate the data exchange model and is generally unnecessary for most communication scenarios. 2. Behavior vs. Data: Methods represent the behavior of the class, while serialization is concerned with transferring the state (data) of the class. The client and service typically communicate using data, and methods are used to process or manipulate that data on the client or server side. 4. Access Methods of a Serialized Object? In WCF, when you serialize and send an object from a service to a client, only the data members of the object (i.e., the properties or fields marked with the [DataMember] attribute) are transferred. Methods, which define behavior, are not serialized. Therefore, the client receives only the data, not the methods or behavior associated with the object. To access methods and perform operations on the serialized data on the client side, you need to follow a different approach: 1. Define Service Contracts: Methods that clients need to call should be part of the WCF service contract. The service contract defines what operations (methods) are available to clients and how they can interact with the service. [ServiceContract] public interface IMyService { [OperationContract] Person GetPersonInfo(int id); } In this example, GetPersonInfo is a method exposed by the service, and it returns a Person object. 2. Implement Service Methods: On the server side, implement the service contract and provide logic for the methods: public class MyService : IMyService { public Person GetPersonInfo(int id) { // Retrieve and return Person object return new Person { FirstName = \"John\", LastName = \"Doe\" }; } } 3. Client-Side Access: On the client side, you interact with the service through a proxy that WCF generates based on the service contract. The client does not directly access methods of the Person class but rather uses the service’s methods to get data and then operates on the data. // Create a client proxy to communicate with the service var client = new MyServiceClient(); // Call the service method Person person = client.GetPersonInfo(123); // Use the data received from the service Console.WriteLine($\"Name: {person.FirstName} {person.LastName}\"); MyServiceClient is a proxy class generated by WCF. Refer blow (next section) for more details. 4. Client Methods and Logic: After receiving the data on the client side, you can implement your own logic or methods to work with the data. For example, you might have methods to process or display the Person data: public class PersonHandler { public void DisplayPersonInfo(Person person) { Console.WriteLine($\"Name: {person.FirstName} {person.LastName}\"); } public string GetFullName(Person person) { return $\"{person.FirstName} {person.LastName}\"; } } In this example, PersonHandler is a client-side class that provides additional functionality related to Person objects. 4.1 Keypoints Service Contracts: Define the methods available for interaction between client and server. Service Implementation: Provides the actual logic for these methods on the server side. Client Proxy: Uses the service contract to call methods and receive data. Client-Side Logic: Implements additional functionality to work with the data received. By designing your WCF service and client interactions this way, you ensure that the client can access and use the methods and logic required to work with the data, even though the methods themselves are not serialized. 4.2 MyServiceClient Proxy Class MyServiceClient is a proxy class generated by WCF that allows a client application to interact with a WCF service. It is not defined by you directly but is created by the WCF tooling based on the service contract defined on the server side. How MyServiceClient is Created 1. Service Reference: When you add a service reference to your client application, Visual Studio (or another tool) generates a client proxy class, such as MyServiceClient, based on the service contract (IMyService) defined on the server. In Visual Studio: You can add a service reference by right-clicking your project, selecting Add Service Reference, and providing the address of the WCF service. Visual Studio generates the proxy classes and configuration needed to communicate with the service. In .NET Core/.NET 5+: You can use the dotnet-svcutil tool or the Connected Services feature in Visual Studio to generate the client proxy. 2. Generated Proxy Class: The generated MyServiceClient class implements the service contract interface (IMyService) and provides methods that correspond to the service operations. It handles the communication details between the client and the WCF service. For example, if you have the following service contract: [ServiceContract] public interface IMyService { [OperationContract] Person GetPersonInfo(int id); } The MyServiceClient class will have a method GetPersonInfo that you can call to interact with the service: public class MyServiceClient : ClientBase&lt;IMyService&gt;, IMyService { public Person GetPersonInfo(int id) { return Channel.GetPersonInfo(id); } } This class is auto-generated and should be used to call service methods. Using the Generated Client Proxy Here’s how you typically use the generated MyServiceClient class in your client application: // Create an instance of the client proxy var client = new MyServiceClient(); // Call the service method Person person = client.GetPersonInfo(123); // Use the data received from the service Console.WriteLine($\"Name: {person.FirstName} {person.LastName}\"); // Optionally, close the client when done client.Close(); Keypoints MyServiceClient is a proxy class generated by WCF tools based on the service contract. It is automatically created when you add a service reference to your client application. You use this proxy class to call methods on the WCF service, which handles the communication details between the client and server. The client proxy provides a convenient way to interact with WCF services without having to deal with low-level communication details."
  },"/dev/distcomp/java/1_basics/": {
    "title": "1. Basics",
    "keywords": "java",
    "url": "/dev/distcomp/java/1_basics/",
    "body": "RabbitMQAppa Appache Kafka"
  }}
