{"/cs/lang_pl/plevolution/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "plevolution",
    "url": "/cs/lang_pl/plevolution/1_basics/",
    "body": ""
  },"/cs/lang_pl/algol/1_background/": {
    "title": "1. Background",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_background/",
    "body": "1. Early Generation Languages Efficiency was critical for early programming languages due to the limited computational resources available at the time. Early computers had minimal processing power, memory, and storage. Efficient programming languages allowed programs to run within these constraints by optimizing resource usage, enabling more complex and useful applications to be executed on the limited hardware. Additionally, efficient code was crucial for real-time processing and scientific computations, which required quick and reliable results. 2. Pseudocode Interpreters Pseudocode interpreters are tools or systems that allow pseudocode, which is an informal high-level description of a computer program’s logic, to be executed or interpreted in a way similar to actual programming languages. These interpreters help bridge the gap between writing pseudocode and implementing the actual code by providing a way to test and validate the logic described in pseudocode. 2.1 Advantages of Pseudocode Interpreters Ease of Learning: They help beginners understand programming concepts without the need to learn complex syntax rules of specific programming languages. Rapid Prototyping: Pseudocode interpreters allow quick testing of algorithms and logic, which can speed up the development process. Focus on Logic: By abstracting away language-specific syntax, pseudocode interpreters enable developers to focus purely on the algorithmic logic. Educational Use: They are valuable in educational settings, providing students with a clear and straightforward way to learn algorithmic thinking and problem-solving. 2.2 Disadvantages of Pseudocode Interpreters Performance: Pseudocode interpreters may not be optimized for performance, making them unsuitable for performance-critical applications. Limited Functionality: They may not support the full range of features and functionalities available in actual programming languages. Lack of Standardization: Pseudocode lacks a standardized syntax, which can lead to inconsistencies and difficulties in interpretation. Transition to Actual Code: While useful for learning and prototyping, pseudocode still needs to be translated into an actual programming language for production use, which can introduce errors. 2.3 Examples of Pseudocode Interpreters Educational Tools: Some educational platforms and tools provide environments where students can write and execute pseudocode. For example, certain online coding platforms offer simplified pseudocode environments for teaching purposes. Algorithm Visualization Tools: Tools that visualize algorithms often use a form of pseudocode to explain the steps of the algorithm, sometimes allowing for interactive execution. 2.4 How Pseudocode Interpreters Work Pseudocode interpreters typically parse the pseudocode, understanding its structure and logic, and then execute the described operations. The interpreter maps pseudocode constructs to actual operations that can be performed on a computer. For example: Variables and Assignments: Interpreters manage variable storage and assignment operations. Control Structures: They interpret and execute loops, conditionals, and other control structures. Functions and Procedures: Some interpreters can handle function and procedure definitions and calls. 2.5 Example Pseudocode and Interpretation Consider the following simple pseudocode for calculating the factorial of a number: function factorial(n) if n == 0 return 1 else return n * factorial(n - 1) A pseudocode interpreter would parse this code, recognize the function, if-else structure, and recursion, and then execute it similarly to how an actual programming language interpreter or compiler would. IMPORTANT Pseudocode interpreters serve as a useful intermediate step between designing an algorithm and implementing it in a full-fledged programming language. They are especially beneficial in educational contexts and for quickly prototyping and testing algorithmic logic. 3. FORTRAN Language 3.1 Syntactic Consistency Principle The Syntactic Consistency Principle refers to the idea that a programming language should have a uniform and predictable syntax. This principle aims to make the language easier to learn, understand, and use by ensuring that similar concepts and constructs are expressed in similar ways throughout the language. Key aspects of syntactic consistency include: Uniform Syntax for Similar Constructs: Similar operations and constructs should use consistent syntax. For example, all control structures (like loops and conditionals) should follow a uniform pattern. Predictable Behavior: The language should behave in a predictable manner, with clear and consistent rules that apply universally. Minimal Exceptions: There should be minimal special cases and exceptions to the syntax rules, reducing the cognitive load on the programmer. 3.1.1 FORTRAN and the Syntactic Consistency Principle FORTRAN (originally written as FORTRAN, later standardized as Fortran) was one of the earliest high-level programming languages, and while it introduced many important concepts, its adherence to the syntactic consistency principle varied across different versions. 3.1.2 Early Versions of FORTRAN Early versions of FORTRAN, such as FORTRAN I and FORTRAN II, had several inconsistencies and irregularities in their syntax. Some notable issues included: Fixed-Format Code: Early FORTRAN required code to adhere to a strict column-based format, which could be confusing and error-prone. Implicit Typing: Variables were implicitly typed based on their names (e.g., variables starting with I, J, K, L, M, N were integers), which could lead to subtle bugs and inconsistencies. GOTO Statements: Heavy reliance on GOTO statements for flow control, which often led to “spaghetti code” and reduced readability and maintainability. 3.1.3 Later Versions of FORTRAN Later versions of FORTRAN, such as FORTRAN 77, FORTRAN 90, and beyond, introduced more syntactic consistency and modern programming constructs. Some improvements included: Free-Format Source Code: The introduction of free-format source code removed the strict column-based formatting requirements. Explicit Typing: Encouragement of explicit typing of variables improved code clarity and reduced errors. Structured Programming Constructs: Introduction of structured programming constructs like DO loops, IF-THEN-ELSE statements, and CASE constructs improved code readability and consistency. 3.1.4 Example Analysis Consider the FORTRAN expression: ( -B + SQRT(B**2 - 4*A*C)) / (2 * A) This expression demonstrates some level of syntactic consistency, as it uses familiar mathematical notation and operators. However, early versions of FORTRAN could have inconsistent handling of spaces and formatting, making it less consistent compared to modern languages. 3.1.5 Comparison with Other Languages C Consistency: C has a fairly consistent syntax, with clear and structured rules for constructs like loops, conditionals, and function definitions. Exceptions: However, C’s syntax can be less intuitive due to low-level operations and pointer usage, which may introduce complexity. Python Consistency: Python is known for its highly consistent and readable syntax. Indentation is used to define code blocks, and constructs are designed to be intuitive and easy to understand. Exceptions: Python has very few exceptions to its syntax rules, making it one of the most syntactically consistent languages. 3.2 The GOTO Statement Effects of Incorrect Use: Readability: Overuse or improper use of GOTO can lead to “spaghetti code,” making programs difficult to read and understand. Maintainability: Code with excessive GOTOs is harder to maintain, as the flow of control is not clear, leading to potential errors and bugs. Debugging: Debugging becomes more complex, as tracking the program flow and identifying issues can be challenging. 3.3 Computed GOTO in FORTRAN The computed GOTO statement in FORTRAN is a control flow construct that allows for branching to one of several labeled statements based on the value of an integer expression. It provides a way to implement conditional jumps, which can be useful in certain scenarios, though it is generally considered less structured and harder to maintain compared to modern control flow constructs like IF and CASE. 3.3.1 Syntax and Mechanism The syntax for the computed GOTO statement is as follows: GOTO (label1, label2, ..., labeln), index label1, label2, ..., labeln: These are the labels of the statements to which control can be transferred. index: This is an integer expression that determines which label to jump to. If index evaluates to 1, control is transferred to label1; if it evaluates to 2, control is transferred to label2, and so on. 3.3.2 Example Here’s a simple example to illustrate the use of computed GOTO: INTEGER :: index index = 3 GOTO (100, 200, 300, 400), index 100 PRINT *, 'Jumped to label 100' GOTO 999 200 PRINT *, 'Jumped to label 200' GOTO 999 300 PRINT *, 'Jumped to label 300' GOTO 999 400 PRINT *, 'Jumped to label 400' GOTO 999 999 PRINT *, 'End of program' END In this example: The index variable is set to 3. The GOTO (100, 200, 300, 400), index statement transfers control to label 300 because the value of index is 3. The program prints “Jumped to label 300” and then continues to the end. 3.3.3 How It Works Evaluate the Index: The integer expression index is evaluated. Determine the Target Label: The value of index determines which label in the list to jump to. For example, if index is 3, the program jumps to the third label in the list. Transfer Control: Control is transferred to the specified label, and the execution of the program continues from that point. 3.3.4 Considerations and Issues While the computed GOTO statement can be useful, it has several drawbacks: Readability: Programs using computed GOTO can be harder to read and understand, as the flow of control is not immediately clear. Maintainability: Such programs are more difficult to maintain and modify because changes to the labels or the logic might require careful updates to the computed GOTO statements. Structured Programming: Modern programming practices favor structured programming constructs (like IF, DO, CASE) over GOTO statements to improve code clarity and reliability. The computed GOTO statement in FORTRAN allows for conditional jumps based on an integer expression, providing a way to implement complex control flows. However, its use is generally discouraged in favor of more structured and maintainable constructs. While it was a common practice in early programming, modern FORTRAN programs typically use structured programming constructs to achieve the same goals more clearly and effectively. 3.4 Information Hiding Early versions of FORTRAN did not support modern concepts of information hiding. However, later versions introduced modules and other constructs to encapsulate data and procedures, allowing for some degree of information hiding and abstraction. Problems with the COMMON block statement in FORTRAN Global Scope: COMMON blocks create global variables, which can be accessed and modified from any part of the program, leading to potential unintended side effects and making debugging difficult. Maintenance: Changes to the COMMON block require changes in all parts of the program that use it, complicating maintenance and updates. Clarity: The use of COMMON blocks can obscure the relationship between different parts of the code, reducing code clarity and increasing the risk of errors. 3.5 Integer Type in Syntax Design In FORTRAN, integer types are straightforward and do not introduce significant syntax complexity. However, the language’s fixed-format requirement for variable names and the lack of flexibility in early versions could make managing integer variables cumbersome. Let’s look at how the fixed-format requirements in FORTRAN 77 can make managing integer variables cumbersome, despite the simplicity of the integer type itself. 3.5.1 Example: Fixed-Format Requirements and Integer Management Fixed-Format Layout Rules: Columns 1-5: Label field (optional) Column 6: Continuation indicator (optional) Columns 7-72: Statement field Columns 73-80: Sequence number (optional, typically for punched cards) Example Code Here is an example where the fixed-format rules make managing integer variables cumbersome: PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END Issues and Adjustments Line Length Constraints: If the integer assignments are too long for the fixed-format line length (columns 7-72), they must be split into continuation lines. Continuation Lines: Properly placing the continuation indicator in column 6 for long statements can be cumbersome and error-prone. Adjusted Code with Continuation Lines PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + &amp;J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END In this adjusted example: The assignment K = I + J is split across two lines because it exceeds the column limit. The continuation character (&amp;) is placed in column 6 of the second line. 3.5.2 Additional Cumbersome Aspects Implicit Typing and Alignment: If implicit typing is used without proper alignment, it can lead to errors. For example: PROGRAM ImplicitTypingExample I = 5 J = 10 PRINT *, 'Sum = ', I + J END Without explicit declarations, if IMPLICIT NONE is not used and variables are not aligned correctly, the compiler might misinterpret the code. Properly Aligned and Explicitly Typed Code: PROGRAM ImplicitTypingExample INTEGER I, J I = 5 J = 10 PRINT *, 'Sum = ', I + J END In this example: Variables I and J are explicitly declared as integers, reducing the risk of misinterpretation. The code adheres to the fixed-format layout, ensuring it is correctly parsed by the compiler. IMPORTANT Even though integer types in FORTRAN 77 are straightforward, the fixed-format requirements can make managing them cumbersome. Properly aligning code, handling continuation lines, and ensuring correct interpretation of implicit types add complexity to writing and maintaining FORTRAN 77 programs. These constraints can lead to errors and make the code harder to read and debug. 3.6 Features That Hinder Security COMMON Blocks: Removing COMMON blocks would reduce the risk of unintended side effects from global variables. GOTO Statements: Eliminating GOTO statements would encourage more structured and readable code, reducing the likelihood of logical errors. Implicit Typing: Requiring explicit type declarations for all variables would prevent type-related errors and improve code clarity. 3.7 Major Contributions High-Level Abstraction: FORTRAN introduced the concept of high-level programming languages, making programming more accessible and abstracting away machine-specific details. Scientific Computing: It became the standard language for scientific and engineering applications, providing powerful numerical and mathematical capabilities. Compiler Development: The development of FORTRAN led to significant advancements in compiler technology, optimizing code generation and execution. 3.8 Major Problems Associated Lack of Modern Features: Early FORTRAN versions lacked modern programming constructs like structured programming, making code more difficult to manage and maintain. Example: Absence of modern data structures like objects and classes. Syntax Limitations: Fixed-format syntax in early versions was restrictive and prone to errors. Example: Columns-based code where indentation errors could lead to misinterpretation of the code. 3.9 Fortran in Modern Days Why has FORTRAN Survived Despite Criticism: Legacy Code: A vast amount of legacy scientific and engineering code written in FORTRAN continues to be used and maintained. Performance: FORTRAN compilers are highly optimized for numerical and scientific computations, often outperforming newer languages in these domains. Specialization: FORTRAN is still highly specialized for certain types of applications, making it the preferred choice for many scientific and engineering tasks. 3.10 Subprograms in FORTRAN FORTRAN was one of the first high-level programming languages to support the creation of subprograms, which greatly enhanced code modularity and reusability. This was achieved primarily through two constructs: functions and subroutines. (1) How Subprograms Were Achieved Functions Functions in FORTRAN are subprograms that return a single value. They are used to encapsulate specific computations and can be invoked within expressions. Syntax: FUNCTION FunctionName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements FunctionName = result ! Return value RETURN END Example: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END Subroutines Subroutines in FORTRAN are more general than functions and do not return a value directly. They are used to perform a series of operations and can modify the values of arguments passed by reference. Syntax: SUBROUTINE SubroutineName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements RETURN END Example: SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END (2) Limitations of FORTRAN Subprograms Lack of Recursion: Early versions of FORTRAN, including FORTRAN 77, did not support recursive subprograms. This limited the ability to write algorithms that naturally use recursion, such as certain types of tree traversals. Limited Scope Rules: FORTRAN had limited support for local variables and scoping rules, leading to potential conflicts and errors in larger programs. Fixed Number of Arguments: Subprograms in FORTRAN 77 required a fixed number of arguments. There was no support for optional or variable-length argument lists. COMMON Blocks for Global Variables: To share variables between subprograms, FORTRAN programmers had to use COMMON blocks, which could lead to maintenance difficulties and unintended side effects. No Modular Programming Support: FORTRAN 77 lacked modern modular programming constructs like modules or namespaces, which are available in later versions like Fortran 90. (3) Graphical Representation of Subprogram Implementation A simple flowchart can be used to represent the implementation of subprograms in FORTRAN. Here is a graphical representation showing the interaction between a main program, a function, and a subroutine. Main Program +---------------------+ | | | +-----------------+ | | | Call Function | | | +-----------------+ | | | | | v | | +-----------------+ | | | Call Subroutine | | | +-----------------+ | | | | | v | | Continue Program | +---------------------+ Function +----------------+ | | | Compute Value | | Return Result | +----------------+ Subroutine +----------------+ | | | Perform Task | | Modify Args | +----------------+ Detailed Flowchart Main Program: Calls the function FunctionName. Receives the result and continues execution. Calls the subroutine SubroutineName. Continues execution after the subroutine returns. Function: Receives arguments. Computes the result. Returns the result to the main program. Subroutine: Receives arguments by reference. Performs tasks and modifies arguments. Returns control to the main program. Example Code for Illustration Main Program: PROGRAM Example IMPLICIT NONE REAL :: a, b, result a = 2.0 b = 3.0 ! Call function result = Square(a) PRINT *, 'Square of ', a, ' is ', result ! Call subroutine CALL Swap(a, b) PRINT *, 'After swap, a = ', a, ' and b = ', b END Function and Subroutine: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END The introduction of subprograms in FORTRAN provided a significant boost to code modularity and reusability, despite certain limitations. By understanding the constraints and leveraging the available constructs, programmers could build more organized and maintainable code, laying the groundwork for modern programming practices."
  },"/cs/lang_pl/fortran/2_basics/": {
    "title": "2. Basics",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/2_basics/",
    "body": "1. Characteristics of Fortran77 Fortran 77 is a significant version of the Fortran programming language, which introduced several features and improvements over its predecessor, Fortran 66. Here are the key characteristics of Fortran 77: 1.1 Fixed-Form Source Code Fortran 77 uses fixed-form source code format, where specific columns in the code have particular meanings. For example, columns 1-5 are used for statement labels, column 6 for continuation characters, and columns 7-72 for code. 1.2 Implicit Typing Variables starting with the letters I through N are implicitly integers, while all other variables are implicitly real numbers, unless explicitly declared otherwise. The IMPLICIT NONE statement can be used to disable implicit typing, forcing all variables to be explicitly declared. 1.3 Improved Control Structures Fortran 77 introduced the IF-THEN-ELSE construct for more readable and flexible conditional branching. The DO loop construct was enhanced, allowing more complex looping structures. 1.4 Data Types Fortran 77 supports basic data types: INTEGER, REAL, DOUBLE PRECISION, COMPLEX, LOGICAL, and CHARACTER. The CHARACTER data type was introduced, enabling better handling of strings. 1.5 Array Handling Fortran 77 allows multi-dimensional arrays, enhancing the language’s capability to handle mathematical and scientific computations involving matrices and tensors. 1.6 COMMON Blocks COMMON blocks in Fortran 77 allow sharing of variables between program units (such as the main program and subroutines). This feature enables global variables and facilitates modular programming. 1.7 Intrinsic Functions Fortran 77 includes a rich set of intrinsic functions for mathematical operations, character manipulation, and logical operations. Examples include SIN, COS, LOG, EXP, SQRT, ABS, and LEN. 1.8 Portability Fortran 77 code is highly portable across different computing platforms, which was a significant improvement over Fortran 66. This standardization helped in the widespread adoption of the language in scientific computing. 1.9 Formatted and Unformatted I/O Fortran 77 provides comprehensive input/output (I/O) capabilities, including both formatted and unformatted I/O operations. The READ, WRITE, and FORMAT statements allow detailed control over data input and output. 1.10 Subroutines and Functions Fortran 77 supports the use of subroutines and functions to promote code reuse and modularity. Subroutines are defined using the SUBROUTINE keyword, and functions using the FUNCTION keyword. 1.11 Example Code Here is a simple example of a Fortran 77 program that demonstrates some of its features: PROGRAM HelloWorld PRINT *, 'Hello, World!' END Example with Control Structures and Arrays PROGRAM ArrayExample INTEGER I, N PARAMETER (N=5) REAL A(N), B(N) ! Initialize arrays DO 10 I = 1, N A(I) = I B(I) = A(I) * A(I) 10 CONTINUE ! Print results PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Explanation The program defines two arrays, A and B, each of size N (which is set to 5). It initializes the array A with values 1 through 5 and computes the square of each element, storing the results in array B. Finally, it prints the contents of both arrays. IMPORTANT Fortran 77 played a crucial role in the evolution of Fortran, providing a solid foundation for scientific and numerical computing with its array handling, control structures, and intrinsic functions. Despite its limitations, it remains an important version of the language, particularly for legacy scientific and engineering codebases. 2. Limitations Fortran 77, while a significant advancement in the Fortran language, also has several downsides and limitations. Here are some of the key disadvantages: 2.1 Fixed-Form Source Code Column Dependency: The fixed-form source code format is rigid and prone to errors. For example, specific columns have designated purposes, and accidental misalignment can lead to syntax errors. Line Length: Code lines are limited to 72 characters, which can lead to cumbersome code formatting and the need for continuation lines. 2.2 Limited Modern Programming Constructs No Dynamic Memory Allocation: Fortran 77 does not support dynamic memory allocation. All arrays and variables must have fixed sizes defined at compile time, which limits flexibility in handling data of varying sizes. No Recursive Procedures: Fortran 77 does not support recursive procedures, which are essential for many modern algorithms and programming techniques. 2.3 Lack of Modular Programming Features No Modules: Fortran 77 does not have modules, making it difficult to encapsulate and organize code. Instead, it relies heavily on COMMON blocks, which can lead to namespace pollution and make code maintenance challenging. No Derived Types: The language does not support user-defined data types (derived types), limiting the ability to create complex data structures. 2.4 Primitive Error Handling Fortran 77 has very basic error handling capabilities. There are no sophisticated mechanisms for catching and handling runtime errors, which can make debugging and developing robust applications more difficult. 2.5 Limited String Handling String manipulation capabilities in Fortran 77 are quite limited compared to modern languages. The CHARACTER data type was introduced in Fortran 77, but string operations are still cumbersome and less powerful. 2.6 Verbosity and Readability Fortran 77 code tends to be verbose, making it harder to read and write compared to more modern programming languages. The syntax can be less intuitive, especially for new programmers. 2.7 No Built-In Support for Parallelism While Fortran is used extensively in high-performance computing, Fortran 77 does not have built-in support for parallel programming. Extensions like MPI and OpenMP must be used to achieve parallelism, which can add complexity. 2.8 Poor Standard Library Support The standard library in Fortran 77 is minimal, offering limited built-in functions and utilities. This lack of extensive libraries can make it harder to perform common tasks without writing substantial amounts of code from scratch. 2.9 Maintenance and Portability Issues Due to its age and the evolution of programming practices, maintaining and updating Fortran 77 code can be challenging. Porting legacy Fortran 77 code to more modern systems or integrating it with contemporary software can also be problematic. 2.10. Example Illustrating Some Downsides Here is a simple example highlighting the fixed-form layout and the limitations in handling dynamic arrays: PROGRAM Example INTEGER A(10), B(10) INTEGER I DO 10 I = 1, 10 A(I) = I B(I) = A(I) * A(I) 10 CONTINUE PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Downsides Illustrated Fixed-Form Layout: The strict column-based format and the need for continuation lines can make the code less readable and more error-prone. No Dynamic Arrays: The arrays A and B must have fixed sizes defined at compile time, limiting flexibility. IMPORTANT While Fortran 77 was a significant step forward for numerical and scientific computing at its time, it has notable limitations and downsides by today’s standards. These include its rigid syntax, lack of modern programming constructs, and limited error handling and string manipulation capabilities. As a result, more recent versions of Fortran and other modern programming languages have largely supplanted Fortran 77 in many areas. 3. GOTO Statement The GOTO statement in Fortran 77, as in many programming languages, is a control flow statement that causes the program to jump to a specified label. It is often considered a controversial feature. Here are the pros and cons of using the GOTO statement in Fortran 77: 3.1 Pros of Using GOTO Simplicity: Fortran 77 does not have some of the more advanced control structures found in modern languages. In certain simple scenarios, using GOTO can make the code straightforward and easy to write. Compatibility: Since Fortran 77 and its predecessors used GOTO extensively, older codebases often rely on it. Understanding and maintaining such code may require familiarity with GOTO. Fine Control: In certain low-level programming scenarios, GOTO can provide fine-grained control over the flow of execution that might be cumbersome to achieve with higher-level constructs. 3.2 Cons of Using GOTO Readability and Maintainability: GOTO can make the code hard to read and understand, as it creates non-linear flow. This is often referred to as “spaghetti code.” Code with many GOTO statements can be challenging to debug and maintain, especially in larger programs. Structured Programming: Structured programming principles advocate for control structures like loops (DO), conditionals (IF-THEN-ELSE), and subroutine calls to improve code readability and maintainability. Excessive use of GOTO undermines these principles. Error-Prone: The use of GOTO can lead to complex and error-prone code, making it easier to introduce bugs, such as infinite loops or jumping to incorrect labels. 3.3 Example of GOTO Usage Here’s a simple example of using GOTO in Fortran 77: PROGRAM GotoExample INTEGER I I = 1 10 IF (I .GT. 10) GOTO 20 PRINT *, 'I =', I I = I + 1 GOTO 10 20 PRINT *, 'Loop finished.' END 3.4 Analysis Readability: The above example is relatively simple, but readability decreases with more complex code involving multiple GOTO statements and labels. Structured Alternative: The same logic can be achieved more readably using a DO loop: PROGRAM DoLoopExample INTEGER I DO 10 I = 1, 10 PRINT *, 'I =', I 10 CONTINUE PRINT *, 'Loop finished.' END Using GOTO in Fortran 77 is generally discouraged except in cases where it simplifies the code or is necessary for compatibility with legacy code. The preference is to use structured programming constructs (like DO loops and IF-THEN-ELSE statements) to improve code readability, maintainability, and reliability. However, understanding GOTO is essential for maintaining and understanding legacy Fortran code."
  },"/cs/lang_pl/fortran/3_programs/": {
    "title": "3. Programs",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/3_programs/",
    "body": "1. Hello World Program program HelloWorld print *, 'Hello, World!' end program HelloWorld To compile and run this program, you can use a Fortran compiler like gfortran. Save the code in a file with a .f90 extension, for example, helloworld.f90, and then use the following commands in your terminal: gfortran -o helloworld helloworld.f90 ./helloworld This will compile the Fortran code and execute the resulting program, displaying the message “Hello, World!” on the screen. 2. COMMON keyword In Fortran 77, the COMMON keyword is used to define and share variables among different program units (such as functions, subroutines, or the main program). This allows for global variables that can be accessed and modified by multiple parts of the program. Here is an example to illustrate the use of the COMMON keyword in Fortran 77: Example PROGRAM Main COMMON /SharedVars/ A, B, C A = 1.0 B = 2.0 C = 3.0 CALL PrintSharedVars END SUBROUTINE PrintSharedVars COMMON /SharedVars/ A, B, C PRINT *, 'A = ', A PRINT *, 'B = ', B PRINT *, 'C = ', C END Explanation Main Program: The COMMON /SharedVars/ A, B, C statement declares a common block named SharedVars that includes the variables A, B, and C. The variables A, B, and C are assigned values 1.0, 2.0, and 3.0 respectively. The CALL PrintSharedVars statement calls the subroutine PrintSharedVars. Subroutine PrintSharedVars: The COMMON /SharedVars/ A, B, C statement declares the same common block SharedVars and the same variables A, B, and C. The PRINT * statements print the values of A, B, and C. Compilation and Execution Save the code in a file with a .f extension, for example, common_example.f, and then use the following commands in your terminal: gfortran -o common_example common_example.f ./common_example The output will be: A = 1.000000 B = 2.000000 C = 3.000000 This demonstrates that the variables A, B, and C are shared between the main program and the subroutine through the common block SharedVars."
  },"/cs/lang_pl/algol/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_basics/",
    "body": ""
  },"/cs/lang_pl/functional/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/1_basics/",
    "body": ""
  },"/cs/lang_pl/logical/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "logical",
    "url": "/cs/lang_pl/logical/1_basics/",
    "body": ""
  },"/cs/lang_pl/scripting/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "scripting",
    "url": "/cs/lang_pl/scripting/1_basics/",
    "body": "Characteristics of Fortran77 Fortran 77 is a significant version of the Fortran programming language, which introduced several features and improvements over its predecessor, Fortran 66. Here are the key characteristics of Fortran 77: 1. Fixed-Form Source Code Fortran 77 uses fixed-form source code format, where specific columns in the code have particular meanings. For example, columns 1-5 are used for statement labels, column 6 for continuation characters, and columns 7-72 for code. 2. Implicit Typing Variables starting with the letters I through N are implicitly integers, while all other variables are implicitly real numbers, unless explicitly declared otherwise. The IMPLICIT NONE statement can be used to disable implicit typing, forcing all variables to be explicitly declared. 3. Improved Control Structures Fortran 77 introduced the IF-THEN-ELSE construct for more readable and flexible conditional branching. The DO loop construct was enhanced, allowing more complex looping structures. 4. Data Types Fortran 77 supports basic data types: INTEGER, REAL, DOUBLE PRECISION, COMPLEX, LOGICAL, and CHARACTER. The CHARACTER data type was introduced, enabling better handling of strings. 5. Array Handling Fortran 77 allows multi-dimensional arrays, enhancing the language’s capability to handle mathematical and scientific computations involving matrices and tensors. 6. COMMON Blocks COMMON blocks in Fortran 77 allow sharing of variables between program units (such as the main program and subroutines). This feature enables global variables and facilitates modular programming. 7. Intrinsic Functions Fortran 77 includes a rich set of intrinsic functions for mathematical operations, character manipulation, and logical operations. Examples include SIN, COS, LOG, EXP, SQRT, ABS, and LEN. 8. Portability Fortran 77 code is highly portable across different computing platforms, which was a significant improvement over Fortran 66. This standardization helped in the widespread adoption of the language in scientific computing. 9. Formatted and Unformatted I/O Fortran 77 provides comprehensive input/output (I/O) capabilities, including both formatted and unformatted I/O operations. The READ, WRITE, and FORMAT statements allow detailed control over data input and output. 10. Subroutines and Functions Fortran 77 supports the use of subroutines and functions to promote code reuse and modularity. Subroutines are defined using the SUBROUTINE keyword, and functions using the FUNCTION keyword. Example Code Here is a simple example of a Fortran 77 program that demonstrates some of its features: PROGRAM HelloWorld PRINT *, 'Hello, World!' END Example with Control Structures and Arrays PROGRAM ArrayExample INTEGER I, N PARAMETER (N=5) REAL A(N), B(N) ! Initialize arrays DO 10 I = 1, N A(I) = I B(I) = A(I) * A(I) 10 CONTINUE ! Print results PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Explanation The program defines two arrays, A and B, each of size N (which is set to 5). It initializes the array A with values 1 through 5 and computes the square of each element, storing the results in array B. Finally, it prints the contents of both arrays. IMPORTANT Fortran 77 played a crucial role in the evolution of Fortran, providing a solid foundation for scientific and numerical computing with its array handling, control structures, and intrinsic functions. Despite its limitations, it remains an important version of the language, particularly for legacy scientific and engineering codebases. 2. Limitations Fortran 77, while a significant advancement in the Fortran language, also has several downsides and limitations. Here are some of the key disadvantages: 1. Fixed-Form Source Code Column Dependency: The fixed-form source code format is rigid and prone to errors. For example, specific columns have designated purposes, and accidental misalignment can lead to syntax errors. Line Length: Code lines are limited to 72 characters, which can lead to cumbersome code formatting and the need for continuation lines. 2. Limited Modern Programming Constructs No Dynamic Memory Allocation: Fortran 77 does not support dynamic memory allocation. All arrays and variables must have fixed sizes defined at compile time, which limits flexibility in handling data of varying sizes. No Recursive Procedures: Fortran 77 does not support recursive procedures, which are essential for many modern algorithms and programming techniques. 3. Lack of Modular Programming Features No Modules: Fortran 77 does not have modules, making it difficult to encapsulate and organize code. Instead, it relies heavily on COMMON blocks, which can lead to namespace pollution and make code maintenance challenging. No Derived Types: The language does not support user-defined data types (derived types), limiting the ability to create complex data structures. 4. Primitive Error Handling Fortran 77 has very basic error handling capabilities. There are no sophisticated mechanisms for catching and handling runtime errors, which can make debugging and developing robust applications more difficult. 5. Limited String Handling String manipulation capabilities in Fortran 77 are quite limited compared to modern languages. The CHARACTER data type was introduced in Fortran 77, but string operations are still cumbersome and less powerful. 6. Verbosity and Readability Fortran 77 code tends to be verbose, making it harder to read and write compared to more modern programming languages. The syntax can be less intuitive, especially for new programmers. 7. No Built-In Support for Parallelism While Fortran is used extensively in high-performance computing, Fortran 77 does not have built-in support for parallel programming. Extensions like MPI and OpenMP must be used to achieve parallelism, which can add complexity. 8. Poor Standard Library Support The standard library in Fortran 77 is minimal, offering limited built-in functions and utilities. This lack of extensive libraries can make it harder to perform common tasks without writing substantial amounts of code from scratch. 9. Maintenance and Portability Issues Due to its age and the evolution of programming practices, maintaining and updating Fortran 77 code can be challenging. Porting legacy Fortran 77 code to more modern systems or integrating it with contemporary software can also be problematic. Example Illustrating Some Downsides Here is a simple example highlighting the fixed-form layout and the limitations in handling dynamic arrays: PROGRAM Example INTEGER A(10), B(10) INTEGER I DO 10 I = 1, 10 A(I) = I B(I) = A(I) * A(I) 10 CONTINUE PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Downsides Illustrated Fixed-Form Layout: The strict column-based format and the need for continuation lines can make the code less readable and more error-prone. No Dynamic Arrays: The arrays A and B must have fixed sizes defined at compile time, limiting flexibility. IMPORTANT While Fortran 77 was a significant step forward for numerical and scientific computing at its time, it has notable limitations and downsides by today’s standards. These include its rigid syntax, lack of modern programming constructs, and limited error handling and string manipulation capabilities. As a result, more recent versions of Fortran and other modern programming languages have largely supplanted Fortran 77 in many areas."
  }}
