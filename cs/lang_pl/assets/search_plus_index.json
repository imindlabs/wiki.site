{"/cs/lang_pl/plevolution/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "plevolution",
    "url": "/cs/lang_pl/plevolution/1_basics/",
    "body": ""
  },"/cs/lang_pl/algol/1_background/": {
    "title": "1. Background",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_background/",
    "body": "1. Early Generation Languages Efficiency was critical for early programming languages due to the limited computational resources available at the time. Early computers had minimal processing power, memory, and storage. Efficient programming languages allowed programs to run within these constraints by optimizing resource usage, enabling more complex and useful applications to be executed on the limited hardware. Additionally, efficient code was crucial for real-time processing and scientific computations, which required quick and reliable results. 2. Pseudocode Interpreters Pseudocode interpreters are tools or systems that allow pseudocode, which is an informal high-level description of a computer program’s logic, to be executed or interpreted in a way similar to actual programming languages. These interpreters help bridge the gap between writing pseudocode and implementing the actual code by providing a way to test and validate the logic described in pseudocode. 2.1 Advantages of Pseudocode Interpreters Ease of Learning: They help beginners understand programming concepts without the need to learn complex syntax rules of specific programming languages. Rapid Prototyping: Pseudocode interpreters allow quick testing of algorithms and logic, which can speed up the development process. Focus on Logic: By abstracting away language-specific syntax, pseudocode interpreters enable developers to focus purely on the algorithmic logic. Educational Use: They are valuable in educational settings, providing students with a clear and straightforward way to learn algorithmic thinking and problem-solving. 2.2 Disadvantages of Pseudocode Interpreters Performance: Pseudocode interpreters may not be optimized for performance, making them unsuitable for performance-critical applications. Limited Functionality: They may not support the full range of features and functionalities available in actual programming languages. Lack of Standardization: Pseudocode lacks a standardized syntax, which can lead to inconsistencies and difficulties in interpretation. Transition to Actual Code: While useful for learning and prototyping, pseudocode still needs to be translated into an actual programming language for production use, which can introduce errors. 2.3 Examples of Pseudocode Interpreters Educational Tools: Some educational platforms and tools provide environments where students can write and execute pseudocode. For example, certain online coding platforms offer simplified pseudocode environments for teaching purposes. Algorithm Visualization Tools: Tools that visualize algorithms often use a form of pseudocode to explain the steps of the algorithm, sometimes allowing for interactive execution. 2.4 How Pseudocode Interpreters Work Pseudocode interpreters typically parse the pseudocode, understanding its structure and logic, and then execute the described operations. The interpreter maps pseudocode constructs to actual operations that can be performed on a computer. For example: Variables and Assignments: Interpreters manage variable storage and assignment operations. Control Structures: They interpret and execute loops, conditionals, and other control structures. Functions and Procedures: Some interpreters can handle function and procedure definitions and calls. 2.5 Example Pseudocode and Interpretation Consider the following simple pseudocode for calculating the factorial of a number: function factorial(n) if n == 0 return 1 else return n * factorial(n - 1) A pseudocode interpreter would parse this code, recognize the function, if-else structure, and recursion, and then execute it similarly to how an actual programming language interpreter or compiler would. IMPORTANT Pseudocode interpreters serve as a useful intermediate step between designing an algorithm and implementing it in a full-fledged programming language. They are especially beneficial in educational contexts and for quickly prototyping and testing algorithmic logic. 3. FORTRAN Language 3.1 Syntactic Consistency Principle The Syntactic Consistency Principle refers to the idea that a programming language should have a uniform and predictable syntax. This principle aims to make the language easier to learn, understand, and use by ensuring that similar concepts and constructs are expressed in similar ways throughout the language. Key aspects of syntactic consistency include: Uniform Syntax for Similar Constructs: Similar operations and constructs should use consistent syntax. For example, all control structures (like loops and conditionals) should follow a uniform pattern. Predictable Behavior: The language should behave in a predictable manner, with clear and consistent rules that apply universally. Minimal Exceptions: There should be minimal special cases and exceptions to the syntax rules, reducing the cognitive load on the programmer. 3.1.1 FORTRAN and the Syntactic Consistency Principle FORTRAN (originally written as FORTRAN, later standardized as Fortran) was one of the earliest high-level programming languages, and while it introduced many important concepts, its adherence to the syntactic consistency principle varied across different versions. 3.1.2 Early Versions of FORTRAN Early versions of FORTRAN, such as FORTRAN I and FORTRAN II, had several inconsistencies and irregularities in their syntax. Some notable issues included: Fixed-Format Code: Early FORTRAN required code to adhere to a strict column-based format, which could be confusing and error-prone. Implicit Typing: Variables were implicitly typed based on their names (e.g., variables starting with I, J, K, L, M, N were integers), which could lead to subtle bugs and inconsistencies. GOTO Statements: Heavy reliance on GOTO statements for flow control, which often led to “spaghetti code” and reduced readability and maintainability. 3.1.3 Later Versions of FORTRAN Later versions of FORTRAN, such as FORTRAN 77, FORTRAN 90, and beyond, introduced more syntactic consistency and modern programming constructs. Some improvements included: Free-Format Source Code: The introduction of free-format source code removed the strict column-based formatting requirements. Explicit Typing: Encouragement of explicit typing of variables improved code clarity and reduced errors. Structured Programming Constructs: Introduction of structured programming constructs like DO loops, IF-THEN-ELSE statements, and CASE constructs improved code readability and consistency. 3.1.4 Example Analysis Consider the FORTRAN expression: ( -B + SQRT(B**2 - 4*A*C)) / (2 * A) This expression demonstrates some level of syntactic consistency, as it uses familiar mathematical notation and operators. However, early versions of FORTRAN could have inconsistent handling of spaces and formatting, making it less consistent compared to modern languages. 3.1.5 Comparison with Other Languages C Consistency: C has a fairly consistent syntax, with clear and structured rules for constructs like loops, conditionals, and function definitions. Exceptions: However, C’s syntax can be less intuitive due to low-level operations and pointer usage, which may introduce complexity. Python Consistency: Python is known for its highly consistent and readable syntax. Indentation is used to define code blocks, and constructs are designed to be intuitive and easy to understand. Exceptions: Python has very few exceptions to its syntax rules, making it one of the most syntactically consistent languages. 3.2 The GOTO Statement Effects of Incorrect Use: Readability: Overuse or improper use of GOTO can lead to “spaghetti code,” making programs difficult to read and understand. Maintainability: Code with excessive GOTOs is harder to maintain, as the flow of control is not clear, leading to potential errors and bugs. Debugging: Debugging becomes more complex, as tracking the program flow and identifying issues can be challenging. 3.3 Computed GOTO in FORTRAN The computed GOTO statement in FORTRAN is a control flow construct that allows for branching to one of several labeled statements based on the value of an integer expression. It provides a way to implement conditional jumps, which can be useful in certain scenarios, though it is generally considered less structured and harder to maintain compared to modern control flow constructs like IF and CASE. 3.3.1 Syntax and Mechanism The syntax for the computed GOTO statement is as follows: GOTO (label1, label2, ..., labeln), index label1, label2, ..., labeln: These are the labels of the statements to which control can be transferred. index: This is an integer expression that determines which label to jump to. If index evaluates to 1, control is transferred to label1; if it evaluates to 2, control is transferred to label2, and so on. 3.3.2 Example Here’s a simple example to illustrate the use of computed GOTO: INTEGER :: index index = 3 GOTO (100, 200, 300, 400), index 100 PRINT *, 'Jumped to label 100' GOTO 999 200 PRINT *, 'Jumped to label 200' GOTO 999 300 PRINT *, 'Jumped to label 300' GOTO 999 400 PRINT *, 'Jumped to label 400' GOTO 999 999 PRINT *, 'End of program' END In this example: The index variable is set to 3. The GOTO (100, 200, 300, 400), index statement transfers control to label 300 because the value of index is 3. The program prints “Jumped to label 300” and then continues to the end. 3.3.3 How It Works Evaluate the Index: The integer expression index is evaluated. Determine the Target Label: The value of index determines which label in the list to jump to. For example, if index is 3, the program jumps to the third label in the list. Transfer Control: Control is transferred to the specified label, and the execution of the program continues from that point. 3.3.4 Considerations and Issues While the computed GOTO statement can be useful, it has several drawbacks: Readability: Programs using computed GOTO can be harder to read and understand, as the flow of control is not immediately clear. Maintainability: Such programs are more difficult to maintain and modify because changes to the labels or the logic might require careful updates to the computed GOTO statements. Structured Programming: Modern programming practices favor structured programming constructs (like IF, DO, CASE) over GOTO statements to improve code clarity and reliability. The computed GOTO statement in FORTRAN allows for conditional jumps based on an integer expression, providing a way to implement complex control flows. However, its use is generally discouraged in favor of more structured and maintainable constructs. While it was a common practice in early programming, modern FORTRAN programs typically use structured programming constructs to achieve the same goals more clearly and effectively. 3.4 Information Hiding Early versions of FORTRAN did not support modern concepts of information hiding. However, later versions introduced modules and other constructs to encapsulate data and procedures, allowing for some degree of information hiding and abstraction. Problems with the COMMON block statement in FORTRAN Global Scope: COMMON blocks create global variables, which can be accessed and modified from any part of the program, leading to potential unintended side effects and making debugging difficult. Maintenance: Changes to the COMMON block require changes in all parts of the program that use it, complicating maintenance and updates. Clarity: The use of COMMON blocks can obscure the relationship between different parts of the code, reducing code clarity and increasing the risk of errors. 3.5 Integer Type in Syntax Design In FORTRAN, integer types are straightforward and do not introduce significant syntax complexity. However, the language’s fixed-format requirement for variable names and the lack of flexibility in early versions could make managing integer variables cumbersome. Let’s look at how the fixed-format requirements in FORTRAN 77 can make managing integer variables cumbersome, despite the simplicity of the integer type itself. 3.5.1 Example: Fixed-Format Requirements and Integer Management Fixed-Format Layout Rules: Columns 1-5: Label field (optional) Column 6: Continuation indicator (optional) Columns 7-72: Statement field Columns 73-80: Sequence number (optional, typically for punched cards) Example Code Here is an example where the fixed-format rules make managing integer variables cumbersome: PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END Issues and Adjustments Line Length Constraints: If the integer assignments are too long for the fixed-format line length (columns 7-72), they must be split into continuation lines. Continuation Lines: Properly placing the continuation indicator in column 6 for long statements can be cumbersome and error-prone. Adjusted Code with Continuation Lines PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + &amp;J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END In this adjusted example: The assignment K = I + J is split across two lines because it exceeds the column limit. The continuation character (&amp;) is placed in column 6 of the second line. 3.5.2 Additional Cumbersome Aspects Implicit Typing and Alignment: If implicit typing is used without proper alignment, it can lead to errors. For example: PROGRAM ImplicitTypingExample I = 5 J = 10 PRINT *, 'Sum = ', I + J END Without explicit declarations, if IMPLICIT NONE is not used and variables are not aligned correctly, the compiler might misinterpret the code. Properly Aligned and Explicitly Typed Code: PROGRAM ImplicitTypingExample INTEGER I, J I = 5 J = 10 PRINT *, 'Sum = ', I + J END In this example: Variables I and J are explicitly declared as integers, reducing the risk of misinterpretation. The code adheres to the fixed-format layout, ensuring it is correctly parsed by the compiler. IMPORTANT Even though integer types in FORTRAN 77 are straightforward, the fixed-format requirements can make managing them cumbersome. Properly aligning code, handling continuation lines, and ensuring correct interpretation of implicit types add complexity to writing and maintaining FORTRAN 77 programs. These constraints can lead to errors and make the code harder to read and debug. 3.6 Features That Hinder Security COMMON Blocks: Removing COMMON blocks would reduce the risk of unintended side effects from global variables. GOTO Statements: Eliminating GOTO statements would encourage more structured and readable code, reducing the likelihood of logical errors. Implicit Typing: Requiring explicit type declarations for all variables would prevent type-related errors and improve code clarity. 3.7 Major Contributions High-Level Abstraction: FORTRAN introduced the concept of high-level programming languages, making programming more accessible and abstracting away machine-specific details. Scientific Computing: It became the standard language for scientific and engineering applications, providing powerful numerical and mathematical capabilities. Compiler Development: The development of FORTRAN led to significant advancements in compiler technology, optimizing code generation and execution. 3.8 Major Problems Associated Lack of Modern Features: Early FORTRAN versions lacked modern programming constructs like structured programming, making code more difficult to manage and maintain. Example: Absence of modern data structures like objects and classes. Syntax Limitations: Fixed-format syntax in early versions was restrictive and prone to errors. Example: Columns-based code where indentation errors could lead to misinterpretation of the code. 3.9 Fortran in Modern Days Why has FORTRAN Survived Despite Criticism: Legacy Code: A vast amount of legacy scientific and engineering code written in FORTRAN continues to be used and maintained. Performance: FORTRAN compilers are highly optimized for numerical and scientific computations, often outperforming newer languages in these domains. Specialization: FORTRAN is still highly specialized for certain types of applications, making it the preferred choice for many scientific and engineering tasks. 3.10 Subprograms in FORTRAN FORTRAN was one of the first high-level programming languages to support the creation of subprograms, which greatly enhanced code modularity and reusability. This was achieved primarily through two constructs: functions and subroutines. (1) How Subprograms Were Achieved Functions Functions in FORTRAN are subprograms that return a single value. They are used to encapsulate specific computations and can be invoked within expressions. Syntax: FUNCTION FunctionName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements FunctionName = result ! Return value RETURN END Example: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END Subroutines Subroutines in FORTRAN are more general than functions and do not return a value directly. They are used to perform a series of operations and can modify the values of arguments passed by reference. Syntax: SUBROUTINE SubroutineName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements RETURN END Example: SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END (2) Limitations of FORTRAN Subprograms Lack of Recursion: Early versions of FORTRAN, including FORTRAN 77, did not support recursive subprograms. This limited the ability to write algorithms that naturally use recursion, such as certain types of tree traversals. Limited Scope Rules: FORTRAN had limited support for local variables and scoping rules, leading to potential conflicts and errors in larger programs. Fixed Number of Arguments: Subprograms in FORTRAN 77 required a fixed number of arguments. There was no support for optional or variable-length argument lists. COMMON Blocks for Global Variables: To share variables between subprograms, FORTRAN programmers had to use COMMON blocks, which could lead to maintenance difficulties and unintended side effects. No Modular Programming Support: FORTRAN 77 lacked modern modular programming constructs like modules or namespaces, which are available in later versions like Fortran 90. (3) Graphical Representation of Subprogram Implementation A simple flowchart can be used to represent the implementation of subprograms in FORTRAN. Here is a graphical representation showing the interaction between a main program, a function, and a subroutine. Main Program +---------------------+ | | | +-----------------+ | | | Call Function | | | +-----------------+ | | | | | v | | +-----------------+ | | | Call Subroutine | | | +-----------------+ | | | | | v | | Continue Program | +---------------------+ Function +----------------+ | | | Compute Value | | Return Result | +----------------+ Subroutine +----------------+ | | | Perform Task | | Modify Args | +----------------+ Detailed Flowchart Main Program: Calls the function FunctionName. Receives the result and continues execution. Calls the subroutine SubroutineName. Continues execution after the subroutine returns. Function: Receives arguments. Computes the result. Returns the result to the main program. Subroutine: Receives arguments by reference. Performs tasks and modifies arguments. Returns control to the main program. Example Code for Illustration Main Program: PROGRAM Example IMPLICIT NONE REAL :: a, b, result a = 2.0 b = 3.0 ! Call function result = Square(a) PRINT *, 'Square of ', a, ' is ', result ! Call subroutine CALL Swap(a, b) PRINT *, 'After swap, a = ', a, ' and b = ', b END Function and Subroutine: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END The introduction of subprograms in FORTRAN provided a significant boost to code modularity and reusability, despite certain limitations. By understanding the constraints and leveraging the available constructs, programmers could build more organized and maintainable code, laying the groundwork for modern programming practices."
  },"/cs/lang_pl/fortran/2_basics/": {
    "title": "2. Basics",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/2_basics/",
    "body": "1. Characteristics of Fortran77 Fortran 77 is a significant version of the Fortran programming language, which introduced several features and improvements over its predecessor, Fortran 66. Here are the key characteristics of Fortran 77: 1.1 Fixed-Form Source Code Fortran 77 uses fixed-form source code format, where specific columns in the code have particular meanings. For example, columns 1-5 are used for statement labels, column 6 for continuation characters, and columns 7-72 for code. 1.2 Implicit Typing Variables starting with the letters I through N are implicitly integers, while all other variables are implicitly real numbers, unless explicitly declared otherwise. The IMPLICIT NONE statement can be used to disable implicit typing, forcing all variables to be explicitly declared. 1.3 Improved Control Structures Fortran 77 introduced the IF-THEN-ELSE construct for more readable and flexible conditional branching. The DO loop construct was enhanced, allowing more complex looping structures. 1.4 Data Types Fortran 77 supports basic data types: INTEGER, REAL, DOUBLE PRECISION, COMPLEX, LOGICAL, and CHARACTER. The CHARACTER data type was introduced, enabling better handling of strings. 1.5 Array Handling Fortran 77 allows multi-dimensional arrays, enhancing the language’s capability to handle mathematical and scientific computations involving matrices and tensors. 1.6 COMMON Blocks COMMON blocks in Fortran 77 allow sharing of variables between program units (such as the main program and subroutines). This feature enables global variables and facilitates modular programming. 1.7 Intrinsic Functions Fortran 77 includes a rich set of intrinsic functions for mathematical operations, character manipulation, and logical operations. Examples include SIN, COS, LOG, EXP, SQRT, ABS, and LEN. 1.8 Portability Fortran 77 code is highly portable across different computing platforms, which was a significant improvement over Fortran 66. This standardization helped in the widespread adoption of the language in scientific computing. 1.9 Formatted and Unformatted I/O Fortran 77 provides comprehensive input/output (I/O) capabilities, including both formatted and unformatted I/O operations. The READ, WRITE, and FORMAT statements allow detailed control over data input and output. 1.10 Subroutines and Functions Fortran 77 supports the use of subroutines and functions to promote code reuse and modularity. Subroutines are defined using the SUBROUTINE keyword, and functions using the FUNCTION keyword. 1.11 Example Code Here is a simple example of a Fortran 77 program that demonstrates some of its features: PROGRAM HelloWorld PRINT *, 'Hello, World!' END Example with Control Structures and Arrays PROGRAM ArrayExample INTEGER I, N PARAMETER (N=5) REAL A(N), B(N) ! Initialize arrays DO 10 I = 1, N A(I) = I B(I) = A(I) * A(I) 10 CONTINUE ! Print results PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Explanation The program defines two arrays, A and B, each of size N (which is set to 5). It initializes the array A with values 1 through 5 and computes the square of each element, storing the results in array B. Finally, it prints the contents of both arrays. IMPORTANT Fortran 77 played a crucial role in the evolution of Fortran, providing a solid foundation for scientific and numerical computing with its array handling, control structures, and intrinsic functions. Despite its limitations, it remains an important version of the language, particularly for legacy scientific and engineering codebases. 2. Limitations Fortran 77, while a significant advancement in the Fortran language, also has several downsides and limitations. Here are some of the key disadvantages: 2.1 Fixed-Form Source Code Column Dependency: The fixed-form source code format is rigid and prone to errors. For example, specific columns have designated purposes, and accidental misalignment can lead to syntax errors. Line Length: Code lines are limited to 72 characters, which can lead to cumbersome code formatting and the need for continuation lines. 2.2 Limited Modern Programming Constructs No Dynamic Memory Allocation: Fortran 77 does not support dynamic memory allocation. All arrays and variables must have fixed sizes defined at compile time, which limits flexibility in handling data of varying sizes. No Recursive Procedures: Fortran 77 does not support recursive procedures, which are essential for many modern algorithms and programming techniques. 2.3 Lack of Modular Programming Features No Modules: Fortran 77 does not have modules, making it difficult to encapsulate and organize code. Instead, it relies heavily on COMMON blocks, which can lead to namespace pollution and make code maintenance challenging. No Derived Types: The language does not support user-defined data types (derived types), limiting the ability to create complex data structures. 2.4 Primitive Error Handling Fortran 77 has very basic error handling capabilities. There are no sophisticated mechanisms for catching and handling runtime errors, which can make debugging and developing robust applications more difficult. 2.5 Limited String Handling String manipulation capabilities in Fortran 77 are quite limited compared to modern languages. The CHARACTER data type was introduced in Fortran 77, but string operations are still cumbersome and less powerful. 2.6 Verbosity and Readability Fortran 77 code tends to be verbose, making it harder to read and write compared to more modern programming languages. The syntax can be less intuitive, especially for new programmers. 2.7 No Built-In Support for Parallelism While Fortran is used extensively in high-performance computing, Fortran 77 does not have built-in support for parallel programming. Extensions like MPI and OpenMP must be used to achieve parallelism, which can add complexity. 2.8 Poor Standard Library Support The standard library in Fortran 77 is minimal, offering limited built-in functions and utilities. This lack of extensive libraries can make it harder to perform common tasks without writing substantial amounts of code from scratch. 2.9 Maintenance and Portability Issues Due to its age and the evolution of programming practices, maintaining and updating Fortran 77 code can be challenging. Porting legacy Fortran 77 code to more modern systems or integrating it with contemporary software can also be problematic. 2.10. Example Illustrating Some Downsides Here is a simple example highlighting the fixed-form layout and the limitations in handling dynamic arrays: PROGRAM Example INTEGER A(10), B(10) INTEGER I DO 10 I = 1, 10 A(I) = I B(I) = A(I) * A(I) 10 CONTINUE PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Downsides Illustrated Fixed-Form Layout: The strict column-based format and the need for continuation lines can make the code less readable and more error-prone. No Dynamic Arrays: The arrays A and B must have fixed sizes defined at compile time, limiting flexibility. IMPORTANT While Fortran 77 was a significant step forward for numerical and scientific computing at its time, it has notable limitations and downsides by today’s standards. These include its rigid syntax, lack of modern programming constructs, and limited error handling and string manipulation capabilities. As a result, more recent versions of Fortran and other modern programming languages have largely supplanted Fortran 77 in many areas. 3. GOTO Statement The GOTO statement in Fortran 77, as in many programming languages, is a control flow statement that causes the program to jump to a specified label. It is often considered a controversial feature. Here are the pros and cons of using the GOTO statement in Fortran 77: 3.1 Pros of Using GOTO Simplicity: Fortran 77 does not have some of the more advanced control structures found in modern languages. In certain simple scenarios, using GOTO can make the code straightforward and easy to write. Compatibility: Since Fortran 77 and its predecessors used GOTO extensively, older codebases often rely on it. Understanding and maintaining such code may require familiarity with GOTO. Fine Control: In certain low-level programming scenarios, GOTO can provide fine-grained control over the flow of execution that might be cumbersome to achieve with higher-level constructs. 3.2 Cons of Using GOTO Readability and Maintainability: GOTO can make the code hard to read and understand, as it creates non-linear flow. This is often referred to as “spaghetti code.” Code with many GOTO statements can be challenging to debug and maintain, especially in larger programs. Structured Programming: Structured programming principles advocate for control structures like loops (DO), conditionals (IF-THEN-ELSE), and subroutine calls to improve code readability and maintainability. Excessive use of GOTO undermines these principles. Error-Prone: The use of GOTO can lead to complex and error-prone code, making it easier to introduce bugs, such as infinite loops or jumping to incorrect labels. 3.3 Example of GOTO Usage Here’s a simple example of using GOTO in Fortran 77: PROGRAM GotoExample INTEGER I I = 1 10 IF (I .GT. 10) GOTO 20 PRINT *, 'I =', I I = I + 1 GOTO 10 20 PRINT *, 'Loop finished.' END 3.4 Analysis Readability: The above example is relatively simple, but readability decreases with more complex code involving multiple GOTO statements and labels. Structured Alternative: The same logic can be achieved more readably using a DO loop: PROGRAM DoLoopExample INTEGER I DO 10 I = 1, 10 PRINT *, 'I =', I 10 CONTINUE PRINT *, 'Loop finished.' END Using GOTO in Fortran 77 is generally discouraged except in cases where it simplifies the code or is necessary for compatibility with legacy code. The preference is to use structured programming constructs (like DO loops and IF-THEN-ELSE statements) to improve code readability, maintainability, and reliability. However, understanding GOTO is essential for maintaining and understanding legacy Fortran code."
  },"/cs/lang_pl/fortran/3_programming_basics/": {
    "title": "3. Programming Basics",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/3_programming_basics/",
    "body": "1. Hello World Program program HelloWorld print *, 'Hello, World!' end program HelloWorld To compile and run this program, you can use a Fortran compiler like gfortran. Save the code in a file with a .f90 extension, for example, helloworld.f90, and then use the following commands in your terminal: gfortran -o helloworld helloworld.f90 ./helloworld This will compile the Fortran code and execute the resulting program, displaying the message “Hello, World!” on the screen. 2. COMMON keyword In Fortran 77, the COMMON keyword is used to define and share variables among different program units (such as functions, subroutines, or the main program). This allows for global variables that can be accessed and modified by multiple parts of the program. Here is an example to illustrate the use of the COMMON keyword in Fortran 77: Example PROGRAM Main COMMON /SharedVars/ A, B, C A = 1.0 B = 2.0 C = 3.0 CALL PrintSharedVars END SUBROUTINE PrintSharedVars COMMON /SharedVars/ A, B, C PRINT *, 'A = ', A PRINT *, 'B = ', B PRINT *, 'C = ', C END Explanation Main Program: The COMMON /SharedVars/ A, B, C statement declares a common block named SharedVars that includes the variables A, B, and C. The variables A, B, and C are assigned values 1.0, 2.0, and 3.0 respectively. The CALL PrintSharedVars statement calls the subroutine PrintSharedVars. Subroutine PrintSharedVars: The COMMON /SharedVars/ A, B, C statement declares the same common block SharedVars and the same variables A, B, and C. The PRINT * statements print the values of A, B, and C. Compilation and Execution Save the code in a file with a .f extension, for example, common_example.f, and then use the following commands in your terminal: gfortran -o common_example common_example.f ./common_example The output will be: A = 1.000000 B = 2.000000 C = 3.000000 This demonstrates that the variables A, B, and C are shared between the main program and the subroutine through the common block SharedVars."
  },"/cs/lang_pl/algol/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_basics/",
    "body": "1.1 Major Contributions of ALGOL-60 ALGOL-60 (Algorithmic Language 1960) made significant contributions to the field of computer science and programming languages: Block Structure: Introduced the concept of block structure, allowing nested blocks and local variables, which led to better-organized and more readable code. Formal Syntax Description: Introduced the Backus-Naur Form (BNF) for describing the syntax of programming languages, a notation that has been widely adopted. Structured Programming: ALGOL-60 laid the groundwork for structured programming by supporting recursive procedures and introducing control structures like if-then-else and for loops. Call by Value and Call by Name: Supported different parameter passing mechanisms, specifically call by value and call by name, providing flexibility in how arguments were passed to procedures. Influence on Later Languages: Many later programming languages, including Pascal, C, and Ada, were heavily influenced by ALGOL-60’s structure and design principles. 1.2 Differences Between ‘Call by Value’, ‘Call by Reference’, and ‘Call by Name’ Call by Value: The actual value of the argument is passed to the function. Inside the function, the parameter is a copy of the argument, so changes made to the parameter do not affect the original argument. Call by Reference: A reference (or address) of the argument is passed to the function. Inside the function, the parameter acts as an alias for the argument, so changes made to the parameter directly affect the original argument. Call by Name: The argument is not evaluated when the function is called. Instead, the expression itself is passed, and it is evaluated every time the parameter is used within the function. This can lead to multiple evaluations and potentially unexpected behavior. 1.3 Issues with ‘Call by Name’ Repeated Evaluation: The argument expression is evaluated every time it is used within the function, which can lead to inefficiency, especially if the expression is complex or if it involves side effects. Complexity: Understanding and debugging code that uses call by name can be more challenging, as the behavior may be less predictable than with call by value or call by reference. Side Effects: If the expression involves side effects (e.g., modifying a global variable), these side effects can occur multiple times, potentially leading to unintended behavior. 1.4 FORTRAN’s Continued Use Despite ALGOL-60’s Contributions FORTRAN (FORmula TRANslation) remained in use and still is today for several reasons: Early Adoption: FORTRAN was one of the first high-level programming languages and became the standard for scientific and engineering computations. Its early adoption established a strong user base. Performance: FORTRAN was designed for numerical computation and optimized for performance, making it a preferred choice in fields where execution speed is critical. Extensive Libraries: Over time, FORTRAN accumulated a vast number of libraries for scientific and numerical computing, making it difficult for other languages to displace it in these areas. Backward Compatibility: FORTRAN maintained backward compatibility with earlier versions, which encouraged continued use and prevented the need for rewriting large amounts of legacy code. 1.5 Difference Between Dynamic and Static Scoping Static Scoping (Lexical Scoping): The scope of a variable is determined by the structure of the program code and the location where the variable is declared. The binding of variables to values occurs at compile time. Most modern programming languages, including C, Java, and Python, use static scoping. Dynamic Scoping: The scope of a variable is determined at runtime based on the calling sequence of functions. The binding of variables to values occurs during execution, and the most recent binding in the call stack is used. Dynamic scoping is less common and is found in languages like early versions of Lisp. 1.6 Differences Between Strong and Weak Typing Strong Typing: In a strongly typed language, the type of a variable is enforced, meaning you cannot perform operations on incompatible types without explicit conversion. Errors are more likely to be caught at compile time. Examples include Java and Python. Weak Typing: In a weakly typed language, type conversions are more flexible, and the language may automatically convert between types. This can lead to more subtle bugs that are harder to detect. Examples include JavaScript and PHP. 1.7 Issue in the C Code Snippet if(x == 0) if(y == 0) x++; else y++; Issue: The problem with this code snippet is related to ambiguity in the else clause. The else statement is associated with the nearest if, so it pairs with if(y == 0) instead of if(x == 0). This might not be the intended behavior. 1.8 How ALGOL-60 Addresses the Issue ALGOL-60 addresses this issue by introducing the concept of explicit block structuring and requiring the use of begin and end to define blocks. In ALGOL-60, the else statement would clearly associate with the intended if due to the enforced block structure, removing ambiguity. 1.9 Two Forms of Type Equivalence Name Equivalence: Two variables are considered equivalent if they have the same type name. The type name explicitly defines the type, and variables must share this name to be considered of the same type. Structural Equivalence: Two variables are considered equivalent if they have the same structure or content, even if their type names are different. The actual composition of the type determines equivalence, not the name. 1.10 Information Stored in an Activation Record An activation record (also known as a stack frame) typically contains the following information: Return Address: The address to which control should return after the function execution is complete. Parameters: The arguments passed to the function. Local Variables: The variables that are local to the function. Saved Registers: The state of certain CPU registers before the function call. Control Link: A reference to the previous activation record (used in dynamic scoping). Access Link: A reference to the activation record of the lexically enclosing function (used in static scoping). Temporary Data: Space for storing intermediate results or temporary values. 1.11 Order of Procedure Calls Given the code provided: PROCEDURE S PROCEDURE A PROCEDURE B PROCEDURE D BEGIN … END; //Procedure D BEGIN __Position 1;__ END; //Procedure B PROCEDURE C; BEGIN B; END; //Procedure C BEGIN C; END; //Procedure A BEGIN A; END; //Procedure S The order of procedure calls is as follows: S is called (as it is the main procedure). A is called from within S. C is called from within A. B is called from within C. Execution reaches Position 1 within B. So, the order of calls is: S → A → C → B. 1.12 Stack Depiction of Static and Dynamic Chains at Position 1 Static Chain: The static chain links an activation record to its lexically enclosing procedure’s activation record. Dynamic Chain: The dynamic chain links an activation record to the activation record of the procedure that called it. At Position 1, the stack would look like this: Top of Stack (B’s Activation Record) Static Link: Points to A (since A lexically encloses B). Dynamic Link: Points to C (since C dynamically called B). A’s Activation Record Static Link: Points to S (since S lexically encloses A). Dynamic Link: Points to S (since S dynamically called A). C’s Activation Record Static Link: Points to A (since A lexically encloses C). Dynamic Link: Points to A (since A dynamically called C). Bottom of Stack (S’s Activation Record) Static Link: Points to Global Frame (since there is no enclosing procedure for S). Dynamic Link: Points to the Global Frame or null. 1.13 Pascal’s Control Structures: Advantageous? Pascal provides a variety of control structures, such as if, case, for, while, and repeat-until. This richness in control structures can be advantageous: Expressiveness: Allows for more expressive and readable code, as different constructs can be used for different scenarios. Clarity: Each control structure is designed for a specific type of task (e.g., case for multi-way branching), which can lead to clearer and more maintainable code. Error Reduction: The use of specific control structures can reduce errors by making the programmer’s intentions more explicit. However, it could also lead to complexity if overused or used inappropriately, making the code harder to follow. 1.14 Pascal’s Implementation of Arrays Pascal implements arrays in a way that was more rigid and structured compared to other contemporary languages: Fixed Bounds: The bounds of Pascal arrays are fixed at compile time, which means the size of the array cannot be changed dynamically. This ensures type safety but reduces flexibility. Strict Type Checking: Pascal enforces strict type checking for arrays, ensuring that operations on arrays are type-safe, which prevents many common programming errors. Static vs. Dynamic Arrays: Pascal originally only supported static arrays (size fixed at compile time). Some later implementations introduced dynamic arrays, but this was not part of the original language. In comparison, languages like C provide more flexibility (e.g., dynamic memory allocation for arrays using pointers), but at the cost of less safety and potentially more errors. 1.15 Pascal’s Handling of Integer and Real Assignments Pascal allows integers to be assigned to real variables but not the other way around. This reflects certain characteristics of the language: Type Safety: By not allowing real variables to be assigned to integers, Pascal enforces type safety, avoiding the loss of precision that could occur when converting from a real number to an integer. Implicit Type Conversion: Allowing integers to be assigned to real variables without explicit conversion is an example of implicit type conversion, making it easier for the programmer but still safe since no precision is lost. Design Philosophy: This decision aligns with Pascal’s design philosophy of promoting safe and structured programming, preventing potential bugs and ensuring that data types are used correctly. 1.16 Functionality of Recursion and Nested Subprograms The functionality of recursion and nested subprograms is highly worthwhile in a programming language. These features enhance the language’s expressiveness, modularity, and abstraction capabilities, making it easier to write clear and maintainable code for complex problems. However, the language and its runtime environment must be designed to handle the potential performance and memory management challenges that recursion introduces. Despite these challenges, the benefits generally outweigh the drawbacks, especially in languages designed for structured and algorithmic programming, as seen in ALGOL-60. 1. Requirements for Allowing Nested Subprograms To support nested subprograms (procedures or functions within other procedures or functions), a programming language must provide: Lexical Scoping: The language must support lexical scoping, where the scope of variables is determined by their position in the source code. This allows variables declared in an outer block to be accessible in inner blocks. Static Chain: The implementation needs a mechanism to maintain the static chain (also known as the lexical chain), which links an activation record (stack frame) of a procedure to the activation record of its lexically enclosing procedure. This allows nested subprograms to access variables from their enclosing scope. Activation Record Management: The runtime system must correctly manage activation records to handle variables and control links, ensuring that the correct variables and procedures are referenced during execution. Name Resolution: The language must resolve names based on the nesting structure, meaning that when an inner subprogram refers to a variable, the compiler or interpreter must be able to find that variable in the appropriate enclosing scope. 2. Requirements for Implementing Recursion To implement recursion in a programming language, the following are necessary: Stack-based Activation Records: Each invocation of a recursive procedure must have its own activation record on the stack. This ensures that local variables and parameters of each recursive call do not interfere with those of other calls. Dynamic Chain: The language must maintain a dynamic chain (call chain) linking activation records in the order they were called. This allows the program to return to the correct point after a recursive call completes. Return Address Handling: The runtime must correctly manage return addresses for each activation record so that after a recursive call completes, the program can return to the appropriate point in the calling procedure. Base Case Identification: For recursion to terminate properly, the language or programmer must identify a base case or stopping condition to prevent infinite recursion. 3. Consideration of Functionality with Respect to Programming Language Characteristics Worthwhile Aspects: Expressiveness: Recursion and nested subprograms enhance the expressiveness of a language, allowing programmers to solve complex problems more naturally, such as in cases involving tree traversal, mathematical computations (like factorials or Fibonacci sequences), and divide-and-conquer algorithms. Modularity and Abstraction: Nested subprograms allow for better modularity and encapsulation. By nesting procedures, a programmer can define helper functions within the scope where they are needed, reducing the chance of name clashes and improving code organization. Reusability: Recursion can lead to more reusable code. Recursive solutions often mirror the problem’s structure, making them easier to understand and reuse across different parts of a program. Challenges: Performance Considerations: Recursive functions can be less efficient due to the overhead of multiple function calls and the potential for deep recursion, leading to stack overflow. Iterative solutions might be more efficient in some cases. Complexity and Readability: While recursion can simplify the code in some scenarios, it can also make it harder to understand, especially for those who are not familiar with the concept. Debugging recursive code can also be more challenging. Memory Management: Recursive calls require careful memory management, particularly in languages with limited stack space. Some languages implement tail recursion optimization to mitigate this, but not all recursive functions can be optimized in this way."
  },"/cs/lang_pl/algol/2_programming_basics/": {
    "title": "2. Programming Basics",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/2_programming_basics/",
    "body": "2.1 Hello World To write and compile a simple program in Algol 68 using the a68g compiler on Ubuntu, follow these steps: Step 1: Install the Algol 68 Compiler (a68g) First, you need to install the a68g compiler. Open your terminal and run the following command: sudo apt-get update sudo apt-get install algol68g This will install the a68g compiler on your system. Step 2: Write a Simple Algol 68 Program Let’s create a simple “Hello, World!” program in Algol 68. Open a text editor (like nano or gedit) and create a new file named hello.alg. nano hello.alg Write the following code into the file: BEGIN print((\"Hello, World!\", newline)) END Save the file and exit the editor (Ctrl + X, then Y to confirm in nano). Step 3: Compile the Algol 68 Program To compile the program using a68g, run the following command in your terminal: a68g hello.alg This command interprets and executes the program directly. Since a68g is an interpreter rather than a traditional compiler, it will run the program and output “Hello, World!” to the terminal immediately. Step 4: Run the Program As a68g is an interpreter, the previous step already executed the program. However, if you want to compile and run it in one step, you can use: a68g -run hello.alg This will output: Hello, World! Additional Notes a68g is an interpreter for Algol 68, so it does not produce a separate compiled binary file like C compilers do. Instead, it reads and executes the source code directly. If you’re writing more complex programs, you can use the same approach, but make sure to structure your code and files accordingly. Algol 68, implemented by the a68g interpreter, provides a rich set of control structures and data structures. Here’s an overview of the control structures and data structures available in Algol 68: 2.2 Control Structures in Algol 68 Conditional Statements IF Statement: Used to make decisions. IF condition THEN statements ELSE statements FI CASE Statement: Multi-way branching. CASE expression IN value1: statements; value2: statements; ... valueN: statements; ESAC Looping Constructs FOR Loop: Iterates over a range of values. FOR i FROM start TO end DO statements OD WHILE Loop: Repeats as long as a condition is true. WHILE condition DO statements OD UNTIL Loop: Repeats until a condition becomes true. UNTIL condition DO statements OD DO Loop: Similar to a while loop, but always executes the loop body at least once. DO statements WHILE condition OD Switch Statements GOTO Statement: Jumps to a labeled statement. GOTO label; EXIT Statement: Exits from a loop. EXIT; Block Structures BEGIN ... END Blocks: Encapsulates a sequence of statements into a block. BEGIN statements END 2.3 Data Structures in Algol 68 Basic Data Types INT: Integer numbers. REAL: Floating-point numbers. BOOL: Boolean values (TRUE or FALSE). CHAR: Single characters. STRING: Sequences of characters. Compound Data Types Arrays: Fixed-size sequences of elements of the same type. [3]INT array := (1, 2, 3); // Array of 3 integers Structures: User-defined types (similar to struct in C). STRUCT ( INT id, STRING name ) person; References: Pointers to data, similar to pointers in C. REF INT refVar := LOC INT; Higher-order Data Types Sets: Collections of elements without duplicates. SET [10]INT set := (1, 2, 3); Unions: A data type that can store different types of data in the same memory location. UNION(INT, REAL) num; Procedures: Functions and subroutines. PROC(INT)INT square = (INT x)INT: x * x; Other Constructs Slices: Subarrays or subranges of arrays. slice := array[2:4]; Rows, Cols, and Strides: Used for multi-dimensional array access. [3,3]INT matrix; matrix[1,2] := 5; 2.4 Example Usage Here is a small example to illustrate some of these control structures and data structures: BEGIN INT x := 5; REAL y := 10.5; [3]INT array := (1, 2, 3); FOR i FROM 1 TO 3 DO print((array[i], \" \")); OD; CASE x IN 1: print((\"One\")); 5: print((\"Five\")); ESAC; PROC(REAL)REAL square = (REAL z) REAL: z * z; print((\"Square of y: \", square(y), newline)); EXIT; END IMPORTANT Algol 68 provides a comprehensive set of control and data structures that make it a versatile language, especially for its time. Its rich syntax for handling control flow and complex data types gives programmers the tools needed for structured and modular programming. 2.5 Procedures and Functions In Algol 68, procedures and functions are fundamental constructs used to encapsulate code that can be reused and executed with different arguments. They allow for modular programming by defining blocks of code that can be invoked with parameters. 1. Procedures in Algol 68 A procedure in Algol 68 is a block of code that performs an operation but does not necessarily return a value. However, in Algol 68, the distinction between procedures and functions is less rigid than in some other languages because both are defined using the PROC keyword, and whether or not they return a value depends on the return type specified. Defining a Procedure To define a procedure, you use the PROC keyword followed by the parameter list and the code block. PROC procedure_name = (parameter_list) VOID: BEGIN -- statements END Example: Simple Procedure PROC print_message = () VOID: BEGIN print((\"Hello, Algol 68!\", newline)) END; BEGIN print_message END PROC print_message = () VOID: defines a procedure named print_message that takes no parameters and returns nothing (VOID). The procedure prints “Hello, Algol 68!” when called. 2. Functions in Algol 68 A function is a special kind of procedure that returns a value. In Algol 68, functions are also defined using the PROC keyword, but with a specified return type. Defining a Function To define a function, you specify the return type after the PROC keyword. PROC function_name = (parameter_list) return_type: BEGIN -- statements return_value END Example: Simple Function PROC sum = (INT a, INT b) INT: a + b; BEGIN INT result := sum(3, 4); print((\"Sum of 3 and 4 is \", result, newline)) END PROC sum = (INT a, INT b) INT: defines a function named sum that takes two integer parameters (a and b) and returns an integer. The function returns the sum of a and b. The result variable stores the returned value from the sum function, which is then printed. 3. Procedures with Return Values (Functions) Since Algol 68 treats procedures and functions similarly, the main difference lies in whether or not a value is returned. Even procedures that return values are defined using the PROC keyword, but they specify a return type rather than VOID. Example: Procedure vs. Function -- Function that returns an integer PROC square = (INT x) INT: x * x; -- Procedure that prints the square PROC print_square = (INT x) VOID: BEGIN print((\"Square of \", x, \" is \", square(x), newline)) END; BEGIN INT y := 5; print_square(y) END square is a function that returns the square of an integer. print_square is a procedure that calls square and prints the result. The print_square procedure does not return a value; it just prints the result. 4. Recursive Functions Algol 68 supports recursive procedures and functions, which means a procedure or function can call itself. Example: Recursive Function PROC factorial = (INT n) INT: BEGIN IF n = 0 THEN 1 ELSE n * factorial(n - 1) FI END; BEGIN INT result := factorial(5); print((\"Factorial of 5 is \", result, newline)) END factorial is a recursive function that calculates the factorial of n. It calls itself with n - 1 until n is 0, at which point it returns 1. 5. Keypoints Procedures in Algol 68 are defined using PROC and typically do not return a value (if VOID is used as the return type). Functions are procedures that return a value and are defined similarly to procedures, but with a specified return type. Both procedures and functions can take parameters and be used for modular and reusable code. Recursive functions are supported, allowing for the implementation of algorithms that involve self-referential logic."
  },"/cs/lang_pl/functional/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/1_basics/",
    "body": ""
  },"/cs/lang_pl/logical/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "logical",
    "url": "/cs/lang_pl/logical/1_basics/",
    "body": ""
  },"/cs/lang_pl/scripting/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "scripting",
    "url": "/cs/lang_pl/scripting/1_basics/",
    "body": ""
  }}
