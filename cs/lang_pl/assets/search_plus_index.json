{"/cs/lang_pl/plevolution/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "plevolution",
    "url": "/cs/lang_pl/plevolution/1_basics/",
    "body": ""
  },"/cs/lang_pl/algol/1_background/": {
    "title": "1. Background",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_background/",
    "body": "1. Early Generation Languages Efficiency was critical for early programming languages due to the limited computational resources available at the time. Early computers had minimal processing power, memory, and storage. Efficient programming languages allowed programs to run within these constraints by optimizing resource usage, enabling more complex and useful applications to be executed on the limited hardware. Additionally, efficient code was crucial for real-time processing and scientific computations, which required quick and reliable results. 2. Pseudocode Interpreters Pseudocode interpreters are tools or systems that allow pseudocode, which is an informal high-level description of a computer program’s logic, to be executed or interpreted in a way similar to actual programming languages. These interpreters help bridge the gap between writing pseudocode and implementing the actual code by providing a way to test and validate the logic described in pseudocode. 2.1 Advantages of Pseudocode Interpreters Ease of Learning: They help beginners understand programming concepts without the need to learn complex syntax rules of specific programming languages. Rapid Prototyping: Pseudocode interpreters allow quick testing of algorithms and logic, which can speed up the development process. Focus on Logic: By abstracting away language-specific syntax, pseudocode interpreters enable developers to focus purely on the algorithmic logic. Educational Use: They are valuable in educational settings, providing students with a clear and straightforward way to learn algorithmic thinking and problem-solving. 2.2 Disadvantages of Pseudocode Interpreters Performance: Pseudocode interpreters may not be optimized for performance, making them unsuitable for performance-critical applications. Limited Functionality: They may not support the full range of features and functionalities available in actual programming languages. Lack of Standardization: Pseudocode lacks a standardized syntax, which can lead to inconsistencies and difficulties in interpretation. Transition to Actual Code: While useful for learning and prototyping, pseudocode still needs to be translated into an actual programming language for production use, which can introduce errors. 2.3 Examples of Pseudocode Interpreters Educational Tools: Some educational platforms and tools provide environments where students can write and execute pseudocode. For example, certain online coding platforms offer simplified pseudocode environments for teaching purposes. Algorithm Visualization Tools: Tools that visualize algorithms often use a form of pseudocode to explain the steps of the algorithm, sometimes allowing for interactive execution. 2.4 How Pseudocode Interpreters Work Pseudocode interpreters typically parse the pseudocode, understanding its structure and logic, and then execute the described operations. The interpreter maps pseudocode constructs to actual operations that can be performed on a computer. For example: Variables and Assignments: Interpreters manage variable storage and assignment operations. Control Structures: They interpret and execute loops, conditionals, and other control structures. Functions and Procedures: Some interpreters can handle function and procedure definitions and calls. 2.5 Example Pseudocode and Interpretation Consider the following simple pseudocode for calculating the factorial of a number: function factorial(n) if n == 0 return 1 else return n * factorial(n - 1) A pseudocode interpreter would parse this code, recognize the function, if-else structure, and recursion, and then execute it similarly to how an actual programming language interpreter or compiler would. IMPORTANT Pseudocode interpreters serve as a useful intermediate step between designing an algorithm and implementing it in a full-fledged programming language. They are especially beneficial in educational contexts and for quickly prototyping and testing algorithmic logic. 3. FORTRAN Language 3.1 Syntactic Consistency Principle The Syntactic Consistency Principle refers to the idea that a programming language should have a uniform and predictable syntax. This principle aims to make the language easier to learn, understand, and use by ensuring that similar concepts and constructs are expressed in similar ways throughout the language. Key aspects of syntactic consistency include: Uniform Syntax for Similar Constructs: Similar operations and constructs should use consistent syntax. For example, all control structures (like loops and conditionals) should follow a uniform pattern. Predictable Behavior: The language should behave in a predictable manner, with clear and consistent rules that apply universally. Minimal Exceptions: There should be minimal special cases and exceptions to the syntax rules, reducing the cognitive load on the programmer. 3.1.1 FORTRAN and the Syntactic Consistency Principle FORTRAN (originally written as FORTRAN, later standardized as Fortran) was one of the earliest high-level programming languages, and while it introduced many important concepts, its adherence to the syntactic consistency principle varied across different versions. 3.1.2 Early Versions of FORTRAN Early versions of FORTRAN, such as FORTRAN I and FORTRAN II, had several inconsistencies and irregularities in their syntax. Some notable issues included: Fixed-Format Code: Early FORTRAN required code to adhere to a strict column-based format, which could be confusing and error-prone. Implicit Typing: Variables were implicitly typed based on their names (e.g., variables starting with I, J, K, L, M, N were integers), which could lead to subtle bugs and inconsistencies. GOTO Statements: Heavy reliance on GOTO statements for flow control, which often led to “spaghetti code” and reduced readability and maintainability. 3.1.3 Later Versions of FORTRAN Later versions of FORTRAN, such as FORTRAN 77, FORTRAN 90, and beyond, introduced more syntactic consistency and modern programming constructs. Some improvements included: Free-Format Source Code: The introduction of free-format source code removed the strict column-based formatting requirements. Explicit Typing: Encouragement of explicit typing of variables improved code clarity and reduced errors. Structured Programming Constructs: Introduction of structured programming constructs like DO loops, IF-THEN-ELSE statements, and CASE constructs improved code readability and consistency. 3.1.4 Example Analysis Consider the FORTRAN expression: ( -B + SQRT(B**2 - 4*A*C)) / (2 * A) This expression demonstrates some level of syntactic consistency, as it uses familiar mathematical notation and operators. However, early versions of FORTRAN could have inconsistent handling of spaces and formatting, making it less consistent compared to modern languages. 3.1.5 Comparison with Other Languages C Consistency: C has a fairly consistent syntax, with clear and structured rules for constructs like loops, conditionals, and function definitions. Exceptions: However, C’s syntax can be less intuitive due to low-level operations and pointer usage, which may introduce complexity. Python Consistency: Python is known for its highly consistent and readable syntax. Indentation is used to define code blocks, and constructs are designed to be intuitive and easy to understand. Exceptions: Python has very few exceptions to its syntax rules, making it one of the most syntactically consistent languages. 3.2 The GOTO Statement Effects of Incorrect Use: Readability: Overuse or improper use of GOTO can lead to “spaghetti code,” making programs difficult to read and understand. Maintainability: Code with excessive GOTOs is harder to maintain, as the flow of control is not clear, leading to potential errors and bugs. Debugging: Debugging becomes more complex, as tracking the program flow and identifying issues can be challenging. 3.3 Computed GOTO in FORTRAN The computed GOTO statement in FORTRAN is a control flow construct that allows for branching to one of several labeled statements based on the value of an integer expression. It provides a way to implement conditional jumps, which can be useful in certain scenarios, though it is generally considered less structured and harder to maintain compared to modern control flow constructs like IF and CASE. 3.3.1 Syntax and Mechanism The syntax for the computed GOTO statement is as follows: GOTO (label1, label2, ..., labeln), index label1, label2, ..., labeln: These are the labels of the statements to which control can be transferred. index: This is an integer expression that determines which label to jump to. If index evaluates to 1, control is transferred to label1; if it evaluates to 2, control is transferred to label2, and so on. 3.3.2 Example Here’s a simple example to illustrate the use of computed GOTO: INTEGER :: index index = 3 GOTO (100, 200, 300, 400), index 100 PRINT *, 'Jumped to label 100' GOTO 999 200 PRINT *, 'Jumped to label 200' GOTO 999 300 PRINT *, 'Jumped to label 300' GOTO 999 400 PRINT *, 'Jumped to label 400' GOTO 999 999 PRINT *, 'End of program' END In this example: The index variable is set to 3. The GOTO (100, 200, 300, 400), index statement transfers control to label 300 because the value of index is 3. The program prints “Jumped to label 300” and then continues to the end. 3.3.3 How It Works Evaluate the Index: The integer expression index is evaluated. Determine the Target Label: The value of index determines which label in the list to jump to. For example, if index is 3, the program jumps to the third label in the list. Transfer Control: Control is transferred to the specified label, and the execution of the program continues from that point. 3.3.4 Considerations and Issues While the computed GOTO statement can be useful, it has several drawbacks: Readability: Programs using computed GOTO can be harder to read and understand, as the flow of control is not immediately clear. Maintainability: Such programs are more difficult to maintain and modify because changes to the labels or the logic might require careful updates to the computed GOTO statements. Structured Programming: Modern programming practices favor structured programming constructs (like IF, DO, CASE) over GOTO statements to improve code clarity and reliability. The computed GOTO statement in FORTRAN allows for conditional jumps based on an integer expression, providing a way to implement complex control flows. However, its use is generally discouraged in favor of more structured and maintainable constructs. While it was a common practice in early programming, modern FORTRAN programs typically use structured programming constructs to achieve the same goals more clearly and effectively. 3.4 Information Hiding Early versions of FORTRAN did not support modern concepts of information hiding. However, later versions introduced modules and other constructs to encapsulate data and procedures, allowing for some degree of information hiding and abstraction. Problems with the COMMON block statement in FORTRAN Global Scope: COMMON blocks create global variables, which can be accessed and modified from any part of the program, leading to potential unintended side effects and making debugging difficult. Maintenance: Changes to the COMMON block require changes in all parts of the program that use it, complicating maintenance and updates. Clarity: The use of COMMON blocks can obscure the relationship between different parts of the code, reducing code clarity and increasing the risk of errors. 3.5 Integer Type in Syntax Design In FORTRAN, integer types are straightforward and do not introduce significant syntax complexity. However, the language’s fixed-format requirement for variable names and the lack of flexibility in early versions could make managing integer variables cumbersome. Let’s look at how the fixed-format requirements in FORTRAN 77 can make managing integer variables cumbersome, despite the simplicity of the integer type itself. 3.5.1 Example: Fixed-Format Requirements and Integer Management Fixed-Format Layout Rules: Columns 1-5: Label field (optional) Column 6: Continuation indicator (optional) Columns 7-72: Statement field Columns 73-80: Sequence number (optional, typically for punched cards) Example Code Here is an example where the fixed-format rules make managing integer variables cumbersome: PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END Issues and Adjustments Line Length Constraints: If the integer assignments are too long for the fixed-format line length (columns 7-72), they must be split into continuation lines. Continuation Lines: Properly placing the continuation indicator in column 6 for long statements can be cumbersome and error-prone. Adjusted Code with Continuation Lines PROGRAM FixedFormatExample INTEGER I, J, K I = 1234567890 J = 2345678901 K = I + &amp;J PRINT *, 'I = ', I PRINT *, 'J = ', J PRINT *, 'K = ', K END In this adjusted example: The assignment K = I + J is split across two lines because it exceeds the column limit. The continuation character (&amp;) is placed in column 6 of the second line. 3.5.2 Additional Cumbersome Aspects Implicit Typing and Alignment: If implicit typing is used without proper alignment, it can lead to errors. For example: PROGRAM ImplicitTypingExample I = 5 J = 10 PRINT *, 'Sum = ', I + J END Without explicit declarations, if IMPLICIT NONE is not used and variables are not aligned correctly, the compiler might misinterpret the code. Properly Aligned and Explicitly Typed Code: PROGRAM ImplicitTypingExample INTEGER I, J I = 5 J = 10 PRINT *, 'Sum = ', I + J END In this example: Variables I and J are explicitly declared as integers, reducing the risk of misinterpretation. The code adheres to the fixed-format layout, ensuring it is correctly parsed by the compiler. IMPORTANT Even though integer types in FORTRAN 77 are straightforward, the fixed-format requirements can make managing them cumbersome. Properly aligning code, handling continuation lines, and ensuring correct interpretation of implicit types add complexity to writing and maintaining FORTRAN 77 programs. These constraints can lead to errors and make the code harder to read and debug. 3.6 Features That Hinder Security COMMON Blocks: Removing COMMON blocks would reduce the risk of unintended side effects from global variables. GOTO Statements: Eliminating GOTO statements would encourage more structured and readable code, reducing the likelihood of logical errors. Implicit Typing: Requiring explicit type declarations for all variables would prevent type-related errors and improve code clarity. 3.7 Major Contributions High-Level Abstraction: FORTRAN introduced the concept of high-level programming languages, making programming more accessible and abstracting away machine-specific details. Scientific Computing: It became the standard language for scientific and engineering applications, providing powerful numerical and mathematical capabilities. Compiler Development: The development of FORTRAN led to significant advancements in compiler technology, optimizing code generation and execution. 3.8 Major Problems Associated Lack of Modern Features: Early FORTRAN versions lacked modern programming constructs like structured programming, making code more difficult to manage and maintain. Example: Absence of modern data structures like objects and classes. Syntax Limitations: Fixed-format syntax in early versions was restrictive and prone to errors. Example: Columns-based code where indentation errors could lead to misinterpretation of the code. 3.9 Fortran in Modern Days Why has FORTRAN Survived Despite Criticism: Legacy Code: A vast amount of legacy scientific and engineering code written in FORTRAN continues to be used and maintained. Performance: FORTRAN compilers are highly optimized for numerical and scientific computations, often outperforming newer languages in these domains. Specialization: FORTRAN is still highly specialized for certain types of applications, making it the preferred choice for many scientific and engineering tasks. 3.10 Subprograms in FORTRAN FORTRAN was one of the first high-level programming languages to support the creation of subprograms, which greatly enhanced code modularity and reusability. This was achieved primarily through two constructs: functions and subroutines. (1) How Subprograms Were Achieved Functions Functions in FORTRAN are subprograms that return a single value. They are used to encapsulate specific computations and can be invoked within expressions. Syntax: FUNCTION FunctionName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements FunctionName = result ! Return value RETURN END Example: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END Subroutines Subroutines in FORTRAN are more general than functions and do not return a value directly. They are used to perform a series of operations and can modify the values of arguments passed by reference. Syntax: SUBROUTINE SubroutineName(arg1, arg2, ...) IMPLICIT NONE ! Declarations ! Statements RETURN END Example: SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END (2) Limitations of FORTRAN Subprograms Lack of Recursion: Early versions of FORTRAN, including FORTRAN 77, did not support recursive subprograms. This limited the ability to write algorithms that naturally use recursion, such as certain types of tree traversals. Limited Scope Rules: FORTRAN had limited support for local variables and scoping rules, leading to potential conflicts and errors in larger programs. Fixed Number of Arguments: Subprograms in FORTRAN 77 required a fixed number of arguments. There was no support for optional or variable-length argument lists. COMMON Blocks for Global Variables: To share variables between subprograms, FORTRAN programmers had to use COMMON blocks, which could lead to maintenance difficulties and unintended side effects. No Modular Programming Support: FORTRAN 77 lacked modern modular programming constructs like modules or namespaces, which are available in later versions like Fortran 90. (3) Graphical Representation of Subprogram Implementation A simple flowchart can be used to represent the implementation of subprograms in FORTRAN. Here is a graphical representation showing the interaction between a main program, a function, and a subroutine. Main Program +---------------------+ | | | +-----------------+ | | | Call Function | | | +-----------------+ | | | | | v | | +-----------------+ | | | Call Subroutine | | | +-----------------+ | | | | | v | | Continue Program | +---------------------+ Function +----------------+ | | | Compute Value | | Return Result | +----------------+ Subroutine +----------------+ | | | Perform Task | | Modify Args | +----------------+ Detailed Flowchart Main Program: Calls the function FunctionName. Receives the result and continues execution. Calls the subroutine SubroutineName. Continues execution after the subroutine returns. Function: Receives arguments. Computes the result. Returns the result to the main program. Subroutine: Receives arguments by reference. Performs tasks and modifies arguments. Returns control to the main program. Example Code for Illustration Main Program: PROGRAM Example IMPLICIT NONE REAL :: a, b, result a = 2.0 b = 3.0 ! Call function result = Square(a) PRINT *, 'Square of ', a, ' is ', result ! Call subroutine CALL Swap(a, b) PRINT *, 'After swap, a = ', a, ' and b = ', b END Function and Subroutine: FUNCTION Square(x) IMPLICIT NONE REAL :: x, Square Square = x * x RETURN END SUBROUTINE Swap(a, b) IMPLICIT NONE REAL :: a, b, temp temp = a a = b b = temp RETURN END The introduction of subprograms in FORTRAN provided a significant boost to code modularity and reusability, despite certain limitations. By understanding the constraints and leveraging the available constructs, programmers could build more organized and maintainable code, laying the groundwork for modern programming practices."
  },"/cs/lang_pl/fortran/2_basics/": {
    "title": "2. Basics",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/2_basics/",
    "body": "1. Characteristics of Fortran77 Fortran 77 is a significant version of the Fortran programming language, which introduced several features and improvements over its predecessor, Fortran 66. Here are the key characteristics of Fortran 77: 1.1 Fixed-Form Source Code Fortran 77 uses fixed-form source code format, where specific columns in the code have particular meanings. For example, columns 1-5 are used for statement labels, column 6 for continuation characters, and columns 7-72 for code. 1.2 Implicit Typing Variables starting with the letters I through N are implicitly integers, while all other variables are implicitly real numbers, unless explicitly declared otherwise. The IMPLICIT NONE statement can be used to disable implicit typing, forcing all variables to be explicitly declared. 1.3 Improved Control Structures Fortran 77 introduced the IF-THEN-ELSE construct for more readable and flexible conditional branching. The DO loop construct was enhanced, allowing more complex looping structures. 1.4 Data Types Fortran 77 supports basic data types: INTEGER, REAL, DOUBLE PRECISION, COMPLEX, LOGICAL, and CHARACTER. The CHARACTER data type was introduced, enabling better handling of strings. 1.5 Array Handling Fortran 77 allows multi-dimensional arrays, enhancing the language’s capability to handle mathematical and scientific computations involving matrices and tensors. 1.6 COMMON Blocks COMMON blocks in Fortran 77 allow sharing of variables between program units (such as the main program and subroutines). This feature enables global variables and facilitates modular programming. 1.7 Intrinsic Functions Fortran 77 includes a rich set of intrinsic functions for mathematical operations, character manipulation, and logical operations. Examples include SIN, COS, LOG, EXP, SQRT, ABS, and LEN. 1.8 Portability Fortran 77 code is highly portable across different computing platforms, which was a significant improvement over Fortran 66. This standardization helped in the widespread adoption of the language in scientific computing. 1.9 Formatted and Unformatted I/O Fortran 77 provides comprehensive input/output (I/O) capabilities, including both formatted and unformatted I/O operations. The READ, WRITE, and FORMAT statements allow detailed control over data input and output. 1.10 Subroutines and Functions Fortran 77 supports the use of subroutines and functions to promote code reuse and modularity. Subroutines are defined using the SUBROUTINE keyword, and functions using the FUNCTION keyword. 1.11 Example Code Here is a simple example of a Fortran 77 program that demonstrates some of its features: PROGRAM HelloWorld PRINT *, 'Hello, World!' END Example with Control Structures and Arrays PROGRAM ArrayExample INTEGER I, N PARAMETER (N=5) REAL A(N), B(N) ! Initialize arrays DO 10 I = 1, N A(I) = I B(I) = A(I) * A(I) 10 CONTINUE ! Print results PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Explanation The program defines two arrays, A and B, each of size N (which is set to 5). It initializes the array A with values 1 through 5 and computes the square of each element, storing the results in array B. Finally, it prints the contents of both arrays. IMPORTANT Fortran 77 played a crucial role in the evolution of Fortran, providing a solid foundation for scientific and numerical computing with its array handling, control structures, and intrinsic functions. Despite its limitations, it remains an important version of the language, particularly for legacy scientific and engineering codebases. 2. Limitations Fortran 77, while a significant advancement in the Fortran language, also has several downsides and limitations. Here are some of the key disadvantages: 2.1 Fixed-Form Source Code Column Dependency: The fixed-form source code format is rigid and prone to errors. For example, specific columns have designated purposes, and accidental misalignment can lead to syntax errors. Line Length: Code lines are limited to 72 characters, which can lead to cumbersome code formatting and the need for continuation lines. 2.2 Limited Modern Programming Constructs No Dynamic Memory Allocation: Fortran 77 does not support dynamic memory allocation. All arrays and variables must have fixed sizes defined at compile time, which limits flexibility in handling data of varying sizes. No Recursive Procedures: Fortran 77 does not support recursive procedures, which are essential for many modern algorithms and programming techniques. 2.3 Lack of Modular Programming Features No Modules: Fortran 77 does not have modules, making it difficult to encapsulate and organize code. Instead, it relies heavily on COMMON blocks, which can lead to namespace pollution and make code maintenance challenging. No Derived Types: The language does not support user-defined data types (derived types), limiting the ability to create complex data structures. 2.4 Primitive Error Handling Fortran 77 has very basic error handling capabilities. There are no sophisticated mechanisms for catching and handling runtime errors, which can make debugging and developing robust applications more difficult. 2.5 Limited String Handling String manipulation capabilities in Fortran 77 are quite limited compared to modern languages. The CHARACTER data type was introduced in Fortran 77, but string operations are still cumbersome and less powerful. 2.6 Verbosity and Readability Fortran 77 code tends to be verbose, making it harder to read and write compared to more modern programming languages. The syntax can be less intuitive, especially for new programmers. 2.7 No Built-In Support for Parallelism While Fortran is used extensively in high-performance computing, Fortran 77 does not have built-in support for parallel programming. Extensions like MPI and OpenMP must be used to achieve parallelism, which can add complexity. 2.8 Poor Standard Library Support The standard library in Fortran 77 is minimal, offering limited built-in functions and utilities. This lack of extensive libraries can make it harder to perform common tasks without writing substantial amounts of code from scratch. 2.9 Maintenance and Portability Issues Due to its age and the evolution of programming practices, maintaining and updating Fortran 77 code can be challenging. Porting legacy Fortran 77 code to more modern systems or integrating it with contemporary software can also be problematic. 2.10. Example Illustrating Some Downsides Here is a simple example highlighting the fixed-form layout and the limitations in handling dynamic arrays: PROGRAM Example INTEGER A(10), B(10) INTEGER I DO 10 I = 1, 10 A(I) = I B(I) = A(I) * A(I) 10 CONTINUE PRINT *, 'Array A:', A PRINT *, 'Array B:', B END Downsides Illustrated Fixed-Form Layout: The strict column-based format and the need for continuation lines can make the code less readable and more error-prone. No Dynamic Arrays: The arrays A and B must have fixed sizes defined at compile time, limiting flexibility. IMPORTANT While Fortran 77 was a significant step forward for numerical and scientific computing at its time, it has notable limitations and downsides by today’s standards. These include its rigid syntax, lack of modern programming constructs, and limited error handling and string manipulation capabilities. As a result, more recent versions of Fortran and other modern programming languages have largely supplanted Fortran 77 in many areas. 3. GOTO Statement The GOTO statement in Fortran 77, as in many programming languages, is a control flow statement that causes the program to jump to a specified label. It is often considered a controversial feature. Here are the pros and cons of using the GOTO statement in Fortran 77: 3.1 Pros of Using GOTO Simplicity: Fortran 77 does not have some of the more advanced control structures found in modern languages. In certain simple scenarios, using GOTO can make the code straightforward and easy to write. Compatibility: Since Fortran 77 and its predecessors used GOTO extensively, older codebases often rely on it. Understanding and maintaining such code may require familiarity with GOTO. Fine Control: In certain low-level programming scenarios, GOTO can provide fine-grained control over the flow of execution that might be cumbersome to achieve with higher-level constructs. 3.2 Cons of Using GOTO Readability and Maintainability: GOTO can make the code hard to read and understand, as it creates non-linear flow. This is often referred to as “spaghetti code.” Code with many GOTO statements can be challenging to debug and maintain, especially in larger programs. Structured Programming: Structured programming principles advocate for control structures like loops (DO), conditionals (IF-THEN-ELSE), and subroutine calls to improve code readability and maintainability. Excessive use of GOTO undermines these principles. Error-Prone: The use of GOTO can lead to complex and error-prone code, making it easier to introduce bugs, such as infinite loops or jumping to incorrect labels. 3.3 Example of GOTO Usage Here’s a simple example of using GOTO in Fortran 77: PROGRAM GotoExample INTEGER I I = 1 10 IF (I .GT. 10) GOTO 20 PRINT *, 'I =', I I = I + 1 GOTO 10 20 PRINT *, 'Loop finished.' END 3.4 Analysis Readability: The above example is relatively simple, but readability decreases with more complex code involving multiple GOTO statements and labels. Structured Alternative: The same logic can be achieved more readably using a DO loop: PROGRAM DoLoopExample INTEGER I DO 10 I = 1, 10 PRINT *, 'I =', I 10 CONTINUE PRINT *, 'Loop finished.' END Using GOTO in Fortran 77 is generally discouraged except in cases where it simplifies the code or is necessary for compatibility with legacy code. The preference is to use structured programming constructs (like DO loops and IF-THEN-ELSE statements) to improve code readability, maintainability, and reliability. However, understanding GOTO is essential for maintaining and understanding legacy Fortran code."
  },"/cs/lang_pl/fortran/3_programming_basics/": {
    "title": "3. Programming Basics",
    "keywords": "fortran",
    "url": "/cs/lang_pl/fortran/3_programming_basics/",
    "body": "1. Hello World Program program HelloWorld print *, 'Hello, World!' end program HelloWorld To compile and run this program, you can use a Fortran compiler like gfortran. Save the code in a file with a .f90 extension, for example, helloworld.f90, and then use the following commands in your terminal: gfortran -o helloworld helloworld.f90 ./helloworld This will compile the Fortran code and execute the resulting program, displaying the message “Hello, World!” on the screen. 2. COMMON keyword In Fortran 77, the COMMON keyword is used to define and share variables among different program units (such as functions, subroutines, or the main program). This allows for global variables that can be accessed and modified by multiple parts of the program. Here is an example to illustrate the use of the COMMON keyword in Fortran 77: Example PROGRAM Main COMMON /SharedVars/ A, B, C A = 1.0 B = 2.0 C = 3.0 CALL PrintSharedVars END SUBROUTINE PrintSharedVars COMMON /SharedVars/ A, B, C PRINT *, 'A = ', A PRINT *, 'B = ', B PRINT *, 'C = ', C END Explanation Main Program: The COMMON /SharedVars/ A, B, C statement declares a common block named SharedVars that includes the variables A, B, and C. The variables A, B, and C are assigned values 1.0, 2.0, and 3.0 respectively. The CALL PrintSharedVars statement calls the subroutine PrintSharedVars. Subroutine PrintSharedVars: The COMMON /SharedVars/ A, B, C statement declares the same common block SharedVars and the same variables A, B, and C. The PRINT * statements print the values of A, B, and C. Compilation and Execution Save the code in a file with a .f extension, for example, common_example.f, and then use the following commands in your terminal: gfortran -o common_example common_example.f ./common_example The output will be: A = 1.000000 B = 2.000000 C = 3.000000 This demonstrates that the variables A, B, and C are shared between the main program and the subroutine through the common block SharedVars."
  },"/cs/lang_pl/algol/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/1_basics/",
    "body": "1.1 Major Contributions of ALGOL-60 ALGOL-60 (Algorithmic Language 1960) made significant contributions to the field of computer science and programming languages: Block Structure: Introduced the concept of block structure, allowing nested blocks and local variables, which led to better-organized and more readable code. Formal Syntax Description: Introduced the Backus-Naur Form (BNF) for describing the syntax of programming languages, a notation that has been widely adopted. Structured Programming: ALGOL-60 laid the groundwork for structured programming by supporting recursive procedures and introducing control structures like if-then-else and for loops. Call by Value and Call by Name: Supported different parameter passing mechanisms, specifically call by value and call by name, providing flexibility in how arguments were passed to procedures. Influence on Later Languages: Many later programming languages, including Pascal, C, and Ada, were heavily influenced by ALGOL-60’s structure and design principles. 1.2 Differences Between ‘Call by Value’, ‘Call by Reference’, and ‘Call by Name’ Call by Value: The actual value of the argument is passed to the function. Inside the function, the parameter is a copy of the argument, so changes made to the parameter do not affect the original argument. Call by Reference: A reference (or address) of the argument is passed to the function. Inside the function, the parameter acts as an alias for the argument, so changes made to the parameter directly affect the original argument. Call by Name: The argument is not evaluated when the function is called. Instead, the expression itself is passed, and it is evaluated every time the parameter is used within the function. This can lead to multiple evaluations and potentially unexpected behavior. 1.3 Issues with ‘Call by Name’ Repeated Evaluation: The argument expression is evaluated every time it is used within the function, which can lead to inefficiency, especially if the expression is complex or if it involves side effects. Complexity: Understanding and debugging code that uses call by name can be more challenging, as the behavior may be less predictable than with call by value or call by reference. Side Effects: If the expression involves side effects (e.g., modifying a global variable), these side effects can occur multiple times, potentially leading to unintended behavior. 1.4 FORTRAN’s Continued Use Despite ALGOL-60’s Contributions FORTRAN (FORmula TRANslation) remained in use and still is today for several reasons: Early Adoption: FORTRAN was one of the first high-level programming languages and became the standard for scientific and engineering computations. Its early adoption established a strong user base. Performance: FORTRAN was designed for numerical computation and optimized for performance, making it a preferred choice in fields where execution speed is critical. Extensive Libraries: Over time, FORTRAN accumulated a vast number of libraries for scientific and numerical computing, making it difficult for other languages to displace it in these areas. Backward Compatibility: FORTRAN maintained backward compatibility with earlier versions, which encouraged continued use and prevented the need for rewriting large amounts of legacy code. 1.5 Difference Between Dynamic and Static Scoping Static Scoping (Lexical Scoping): The scope of a variable is determined by the structure of the program code and the location where the variable is declared. The binding of variables to values occurs at compile time. Most modern programming languages, including C, Java, and Python, use static scoping. Dynamic Scoping: The scope of a variable is determined at runtime based on the calling sequence of functions. The binding of variables to values occurs during execution, and the most recent binding in the call stack is used. Dynamic scoping is less common and is found in languages like early versions of Lisp. 1.6 Differences Between Strong and Weak Typing Strong Typing: In a strongly typed language, the type of a variable is enforced, meaning you cannot perform operations on incompatible types without explicit conversion. Errors are more likely to be caught at compile time. Examples include Java and Python. Weak Typing: In a weakly typed language, type conversions are more flexible, and the language may automatically convert between types. This can lead to more subtle bugs that are harder to detect. Examples include JavaScript and PHP. 1.7 Issue in the C Code Snippet if(x == 0) if(y == 0) x++; else y++; Issue: The problem with this code snippet is related to ambiguity in the else clause. The else statement is associated with the nearest if, so it pairs with if(y == 0) instead of if(x == 0). This might not be the intended behavior. 1.8 How ALGOL-60 Addresses the Issue ALGOL-60 addresses this issue by introducing the concept of explicit block structuring and requiring the use of begin and end to define blocks. In ALGOL-60, the else statement would clearly associate with the intended if due to the enforced block structure, removing ambiguity. 1.9 Two Forms of Type Equivalence Name Equivalence: Two variables are considered equivalent if they have the same type name. The type name explicitly defines the type, and variables must share this name to be considered of the same type. Structural Equivalence: Two variables are considered equivalent if they have the same structure or content, even if their type names are different. The actual composition of the type determines equivalence, not the name. 1.10 Information Stored in an Activation Record An activation record (also known as a stack frame) typically contains the following information: Return Address: The address to which control should return after the function execution is complete. Parameters: The arguments passed to the function. Local Variables: The variables that are local to the function. Saved Registers: The state of certain CPU registers before the function call. Control Link: A reference to the previous activation record (used in dynamic scoping). Access Link: A reference to the activation record of the lexically enclosing function (used in static scoping). Temporary Data: Space for storing intermediate results or temporary values. 1.11 Order of Procedure Calls Given the code provided: PROCEDURE S PROCEDURE A PROCEDURE B PROCEDURE D BEGIN … END; //Procedure D BEGIN __Position 1;__ END; //Procedure B PROCEDURE C; BEGIN B; END; //Procedure C BEGIN C; END; //Procedure A BEGIN A; END; //Procedure S The order of procedure calls is as follows: S is called (as it is the main procedure). A is called from within S. C is called from within A. B is called from within C. Execution reaches Position 1 within B. So, the order of calls is: S → A → C → B. 1.12 Stack Depiction of Static and Dynamic Chains at Position 1 Static Chain: The static chain links an activation record to its lexically enclosing procedure’s activation record. Dynamic Chain: The dynamic chain links an activation record to the activation record of the procedure that called it. At Position 1, the stack would look like this: Top of Stack (B’s Activation Record) Static Link: Points to A (since A lexically encloses B). Dynamic Link: Points to C (since C dynamically called B). A’s Activation Record Static Link: Points to S (since S lexically encloses A). Dynamic Link: Points to S (since S dynamically called A). C’s Activation Record Static Link: Points to A (since A lexically encloses C). Dynamic Link: Points to A (since A dynamically called C). Bottom of Stack (S’s Activation Record) Static Link: Points to Global Frame (since there is no enclosing procedure for S). Dynamic Link: Points to the Global Frame or null. 1.13 Pascal’s Control Structures: Advantageous? Pascal provides a variety of control structures, such as if, case, for, while, and repeat-until. This richness in control structures can be advantageous: Expressiveness: Allows for more expressive and readable code, as different constructs can be used for different scenarios. Clarity: Each control structure is designed for a specific type of task (e.g., case for multi-way branching), which can lead to clearer and more maintainable code. Error Reduction: The use of specific control structures can reduce errors by making the programmer’s intentions more explicit. However, it could also lead to complexity if overused or used inappropriately, making the code harder to follow. 1.14 Pascal’s Implementation of Arrays Pascal implements arrays in a way that was more rigid and structured compared to other contemporary languages: Fixed Bounds: The bounds of Pascal arrays are fixed at compile time, which means the size of the array cannot be changed dynamically. This ensures type safety but reduces flexibility. Strict Type Checking: Pascal enforces strict type checking for arrays, ensuring that operations on arrays are type-safe, which prevents many common programming errors. Static vs. Dynamic Arrays: Pascal originally only supported static arrays (size fixed at compile time). Some later implementations introduced dynamic arrays, but this was not part of the original language. In comparison, languages like C provide more flexibility (e.g., dynamic memory allocation for arrays using pointers), but at the cost of less safety and potentially more errors. 1.15 Pascal’s Handling of Integer and Real Assignments Pascal allows integers to be assigned to real variables but not the other way around. This reflects certain characteristics of the language: Type Safety: By not allowing real variables to be assigned to integers, Pascal enforces type safety, avoiding the loss of precision that could occur when converting from a real number to an integer. Implicit Type Conversion: Allowing integers to be assigned to real variables without explicit conversion is an example of implicit type conversion, making it easier for the programmer but still safe since no precision is lost. Design Philosophy: This decision aligns with Pascal’s design philosophy of promoting safe and structured programming, preventing potential bugs and ensuring that data types are used correctly. 1.16 Functionality of Recursion and Nested Subprograms The functionality of recursion and nested subprograms is highly worthwhile in a programming language. These features enhance the language’s expressiveness, modularity, and abstraction capabilities, making it easier to write clear and maintainable code for complex problems. However, the language and its runtime environment must be designed to handle the potential performance and memory management challenges that recursion introduces. Despite these challenges, the benefits generally outweigh the drawbacks, especially in languages designed for structured and algorithmic programming, as seen in ALGOL-60. 1. Requirements for Allowing Nested Subprograms To support nested subprograms (procedures or functions within other procedures or functions), a programming language must provide: Lexical Scoping: The language must support lexical scoping, where the scope of variables is determined by their position in the source code. This allows variables declared in an outer block to be accessible in inner blocks. Static Chain: The implementation needs a mechanism to maintain the static chain (also known as the lexical chain), which links an activation record (stack frame) of a procedure to the activation record of its lexically enclosing procedure. This allows nested subprograms to access variables from their enclosing scope. Activation Record Management: The runtime system must correctly manage activation records to handle variables and control links, ensuring that the correct variables and procedures are referenced during execution. Name Resolution: The language must resolve names based on the nesting structure, meaning that when an inner subprogram refers to a variable, the compiler or interpreter must be able to find that variable in the appropriate enclosing scope. 2. Requirements for Implementing Recursion To implement recursion in a programming language, the following are necessary: Stack-based Activation Records: Each invocation of a recursive procedure must have its own activation record on the stack. This ensures that local variables and parameters of each recursive call do not interfere with those of other calls. Dynamic Chain: The language must maintain a dynamic chain (call chain) linking activation records in the order they were called. This allows the program to return to the correct point after a recursive call completes. Return Address Handling: The runtime must correctly manage return addresses for each activation record so that after a recursive call completes, the program can return to the appropriate point in the calling procedure. Base Case Identification: For recursion to terminate properly, the language or programmer must identify a base case or stopping condition to prevent infinite recursion. 3. Consideration of Functionality with Respect to Programming Language Characteristics Worthwhile Aspects: Expressiveness: Recursion and nested subprograms enhance the expressiveness of a language, allowing programmers to solve complex problems more naturally, such as in cases involving tree traversal, mathematical computations (like factorials or Fibonacci sequences), and divide-and-conquer algorithms. Modularity and Abstraction: Nested subprograms allow for better modularity and encapsulation. By nesting procedures, a programmer can define helper functions within the scope where they are needed, reducing the chance of name clashes and improving code organization. Reusability: Recursion can lead to more reusable code. Recursive solutions often mirror the problem’s structure, making them easier to understand and reuse across different parts of a program. Challenges: Performance Considerations: Recursive functions can be less efficient due to the overhead of multiple function calls and the potential for deep recursion, leading to stack overflow. Iterative solutions might be more efficient in some cases. Complexity and Readability: While recursion can simplify the code in some scenarios, it can also make it harder to understand, especially for those who are not familiar with the concept. Debugging recursive code can also be more challenging. Memory Management: Recursive calls require careful memory management, particularly in languages with limited stack space. Some languages implement tail recursion optimization to mitigate this, but not all recursive functions can be optimized in this way."
  },"/cs/lang_pl/algol/2_programming_basics/": {
    "title": "2. Programming Basics",
    "keywords": "algol",
    "url": "/cs/lang_pl/algol/2_programming_basics/",
    "body": "2.1 Hello World To write and compile a simple program in Algol 68 using the a68g compiler on Ubuntu, follow these steps: Step 1: Install the Algol 68 Compiler (a68g) First, you need to install the a68g compiler. Open your terminal and run the following command: sudo apt-get update sudo apt-get install algol68g This will install the a68g compiler on your system. Step 2: Write a Simple Algol 68 Program Let’s create a simple “Hello, World!” program in Algol 68. Open a text editor (like nano or gedit) and create a new file named hello.alg. nano hello.alg Write the following code into the file: BEGIN print((\"Hello, World!\", newline)) END Save the file and exit the editor (Ctrl + X, then Y to confirm in nano). Step 3: Compile the Algol 68 Program To compile the program using a68g, run the following command in your terminal: a68g hello.alg This command interprets and executes the program directly. Since a68g is an interpreter rather than a traditional compiler, it will run the program and output “Hello, World!” to the terminal immediately. Step 4: Run the Program As a68g is an interpreter, the previous step already executed the program. However, if you want to compile and run it in one step, you can use: a68g -run hello.alg This will output: Hello, World! Additional Notes a68g is an interpreter for Algol 68, so it does not produce a separate compiled binary file like C compilers do. Instead, it reads and executes the source code directly. If you’re writing more complex programs, you can use the same approach, but make sure to structure your code and files accordingly. Algol 68, implemented by the a68g interpreter, provides a rich set of control structures and data structures. Here’s an overview of the control structures and data structures available in Algol 68: 2.2 Control Structures in Algol 68 Conditional Statements IF Statement: Used to make decisions. IF condition THEN statements ELSE statements FI CASE Statement: Multi-way branching. CASE expression IN value1: statements; value2: statements; ... valueN: statements; ESAC Looping Constructs FOR Loop: Iterates over a range of values. FOR i FROM start TO end DO statements OD WHILE Loop: Repeats as long as a condition is true. WHILE condition DO statements OD UNTIL Loop: Repeats until a condition becomes true. UNTIL condition DO statements OD DO Loop: Similar to a while loop, but always executes the loop body at least once. DO statements WHILE condition OD Switch Statements GOTO Statement: Jumps to a labeled statement. GOTO label; EXIT Statement: Exits from a loop. EXIT; Block Structures BEGIN ... END Blocks: Encapsulates a sequence of statements into a block. BEGIN statements END 2.3 Data Structures in Algol 68 Basic Data Types INT: Integer numbers. REAL: Floating-point numbers. BOOL: Boolean values (TRUE or FALSE). CHAR: Single characters. STRING: Sequences of characters. Compound Data Types Arrays: Fixed-size sequences of elements of the same type. [3]INT array := (1, 2, 3); // Array of 3 integers Structures: User-defined types (similar to struct in C). STRUCT ( INT id, STRING name ) person; References: Pointers to data, similar to pointers in C. REF INT refVar := LOC INT; Higher-order Data Types Sets: Collections of elements without duplicates. SET [10]INT set := (1, 2, 3); Unions: A data type that can store different types of data in the same memory location. UNION(INT, REAL) num; Procedures: Functions and subroutines. PROC(INT)INT square = (INT x)INT: x * x; Other Constructs Slices: Subarrays or subranges of arrays. slice := array[2:4]; Rows, Cols, and Strides: Used for multi-dimensional array access. [3,3]INT matrix; matrix[1,2] := 5; 2.4 Example Usage Here is a small example to illustrate some of these control structures and data structures: BEGIN INT x := 5; REAL y := 10.5; [3]INT array := (1, 2, 3); FOR i FROM 1 TO 3 DO print((array[i], \" \")); OD; CASE x IN 1: print((\"One\")); 5: print((\"Five\")); ESAC; PROC(REAL)REAL square = (REAL z) REAL: z * z; print((\"Square of y: \", square(y), newline)); EXIT; END IMPORTANT Algol 68 provides a comprehensive set of control and data structures that make it a versatile language, especially for its time. Its rich syntax for handling control flow and complex data types gives programmers the tools needed for structured and modular programming. 2.5 Procedures and Functions In Algol 68, procedures and functions are fundamental constructs used to encapsulate code that can be reused and executed with different arguments. They allow for modular programming by defining blocks of code that can be invoked with parameters. 1. Procedures in Algol 68 A procedure in Algol 68 is a block of code that performs an operation but does not necessarily return a value. However, in Algol 68, the distinction between procedures and functions is less rigid than in some other languages because both are defined using the PROC keyword, and whether or not they return a value depends on the return type specified. Defining a Procedure To define a procedure, you use the PROC keyword followed by the parameter list and the code block. PROC procedure_name = (parameter_list) VOID: BEGIN -- statements END Example: Simple Procedure PROC print_message = () VOID: BEGIN print((\"Hello, Algol 68!\", newline)) END; BEGIN print_message END PROC print_message = () VOID: defines a procedure named print_message that takes no parameters and returns nothing (VOID). The procedure prints “Hello, Algol 68!” when called. 2. Functions in Algol 68 A function is a special kind of procedure that returns a value. In Algol 68, functions are also defined using the PROC keyword, but with a specified return type. Defining a Function To define a function, you specify the return type after the PROC keyword. PROC function_name = (parameter_list) return_type: BEGIN -- statements return_value END Example: Simple Function PROC sum = (INT a, INT b) INT: a + b; BEGIN INT result := sum(3, 4); print((\"Sum of 3 and 4 is \", result, newline)) END PROC sum = (INT a, INT b) INT: defines a function named sum that takes two integer parameters (a and b) and returns an integer. The function returns the sum of a and b. The result variable stores the returned value from the sum function, which is then printed. 3. Procedures with Return Values (Functions) Since Algol 68 treats procedures and functions similarly, the main difference lies in whether or not a value is returned. Even procedures that return values are defined using the PROC keyword, but they specify a return type rather than VOID. Example: Procedure vs. Function -- Function that returns an integer PROC square = (INT x) INT: x * x; -- Procedure that prints the square PROC print_square = (INT x) VOID: BEGIN print((\"Square of \", x, \" is \", square(x), newline)) END; BEGIN INT y := 5; print_square(y) END square is a function that returns the square of an integer. print_square is a procedure that calls square and prints the result. The print_square procedure does not return a value; it just prints the result. 4. Recursive Functions Algol 68 supports recursive procedures and functions, which means a procedure or function can call itself. Example: Recursive Function PROC factorial = (INT n) INT: BEGIN IF n = 0 THEN 1 ELSE n * factorial(n - 1) FI END; BEGIN INT result := factorial(5); print((\"Factorial of 5 is \", result, newline)) END factorial is a recursive function that calculates the factorial of n. It calls itself with n - 1 until n is 0, at which point it returns 1. 5. Keypoints Procedures in Algol 68 are defined using PROC and typically do not return a value (if VOID is used as the return type). Functions are procedures that return a value and are defined similarly to procedures, but with a specified return type. Both procedures and functions can take parameters and be used for modular and reusable code. Recursive functions are supported, allowing for the implementation of algorithms that involve self-referential logic."
  },"/cs/lang_pl/functional/1_elixir_1_basics/": {
    "title": "1. Elixir",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/1_elixir_1_basics/",
    "body": "1.1 Introduction Elixir is a dynamic, functional programming language designed for building scalable and maintainable applications. It runs on the Erlang Virtual Machine (BEAM), which is known for its low-latency, distributed, and fault-tolerant systems. Elixir is widely used for web development, real-time applications, and distributed systems due to its concurrency capabilities and fault-tolerance features. 1. Key Features of Elixir: Functional Programming: Focuses on immutability and first-class functions. Concurrency: Uses lightweight processes to handle concurrent tasks efficiently. Fault Tolerance: Built on Erlang’s “let it crash” philosophy, allowing systems to recover from failures gracefully. Metaprogramming: Supports macros, allowing code to generate code. Scalability: Designed to handle large-scale distributed applications. 2. Pros of Elixir 1. Concurrency and Scalability: Elixir excels in handling many concurrent processes due to its lightweight process model (inherited from Erlang). This makes it ideal for real-time applications, chat systems, IoT, and any situation requiring high concurrency. 2. Fault Tolerance: Built on the Erlang VM (BEAM), Elixir inherits a “let it crash” philosophy. The language is designed for building fault-tolerant systems that can recover automatically from failures, making it suitable for highly reliable, distributed systems. 3. Functional Programming: Elixir’s functional nature encourages immutability and pure functions, leading to more predictable and maintainable code. This paradigm reduces side effects, making code easier to reason about, test, and debug. 4. Metaprogramming: Elixir supports powerful metaprogramming through macros, allowing developers to write code that generates code. This can lead to more flexible and reusable codebases. 5. Active Community and Ecosystem: Elixir has a growing community and a rich ecosystem of libraries and tools, including Phoenix (a popular web framework). The community is known for its friendliness and support. 6. Ease of Deployment: Elixir’s deployment story is strong, especially with tools like Distillery and Mix, which make it easy to build and deploy releases across distributed systems. 7. Real-time Capabilities: Elixir, particularly with the Phoenix framework, offers built-in support for real-time features like websockets and channels, making it a top choice for real-time applications. 3. Cons of Elixir 1. Learning Curve: For developers coming from imperative or object-oriented backgrounds, the functional programming paradigm, as well as concepts like immutability and recursion, can take some time to master. 2. Performance: While Elixir performs well in I/O-bound and concurrent tasks, it may not match the raw computational performance of languages like C, Rust, or even Java for CPU-bound tasks. This is due to its dynamic nature and the overhead of running on the BEAM. 3. Smaller Talent Pool: Compared to languages like JavaScript, Python, or Java, the pool of Elixir developers is smaller. This can make it more difficult to hire Elixir developers, especially those with experience in large-scale production environments. 4. Tooling and Libraries: Although Elixir’s ecosystem is robust and growing, it still lags behind older, more established languages in terms of the breadth and depth of available libraries and tools. 5. Maturity: Elixir, while stable and mature in many ways, is still relatively young compared to languages like Java or Python. This can sometimes result in less mature tooling, fewer enterprise-level case studies, and a more experimental feel in certain areas. 6. Niche Use Cases: Elixir is fantastic for concurrent, distributed, and fault-tolerant systems but may be overkill for simpler projects where such features are not needed. For basic CRUD apps or simple scripts, more straightforward languages might be a better fit. 7. Deployment Complexity in Certain Environments: While Elixir’s deployment story is strong, deploying distributed Elixir systems can be complex, especially for teams unfamiliar with Erlang/BEAM architecture. Handling node clustering and network partitions requires a deep understanding of the underlying system. TIP Elixir’s strengths lie in its ability to build scalable, fault-tolerant, and concurrent systems with ease, making it an excellent choice for web development, real-time applications, and distributed systems. However, it comes with a learning curve, a smaller talent pool, and some performance limitations for CPU-bound tasks. Teams should carefully consider these factors when deciding if Elixir is the right tool for their specific needs. 4. Comparison Between Elixir and C: Feature Elixir C Paradigm Functional, Concurrent Procedural, Low-level Memory Management Automatic (Garbage Collection) Manual (malloc/free) Concurrency Model Actor model with lightweight processes Threads, but manual handling required Compilation Runs on BEAM (Erlang VM), compiled to bytecode Compiled to machine code, highly optimized Performance High for I/O-bound tasks, not CPU-bound High performance, especially for CPU-bound tasks Fault Tolerance High (let it crash philosophy) Limited, must be managed manually Use Cases Web apps, real-time systems, distributed apps System programming, embedded systems, performance-critical applications Syntax Dynamic and expressive Low-level, closer to hardware Type System Dynamic typing Static typing Standard Library Extensive, high-level functions Minimal, relies heavily on external libraries 5. Key Differences: 1. Programming Paradigm: Elixir: Emphasizes functional programming, where functions are first-class citizens and data is immutable. C: Procedural and imperative, focusing on explicit control flow and mutable state. 2. Concurrency: Elixir: Built-in concurrency support using the actor model, allowing easy management of millions of lightweight processes. C: Requires manual management of threads, synchronization, and shared memory, which is complex and error-prone. 3. Memory Management: Elixir: Automatic memory management with garbage collection. C: Manual memory management, giving more control but also requiring careful handling to avoid memory leaks or corruption. 4. Performance: C: Typically faster and more efficient for CPU-bound tasks due to direct compilation to machine code. Elixir: Optimized for I/O-bound and concurrent tasks, but not as fast for raw computation. 5. Fault Tolerance: Elixir: Highly resilient, designed for long-running, distributed systems that need to recover gracefully from failures. C: Fault tolerance needs to be manually implemented, and errors can lead to undefined behavior or crashes. 6. Development Speed: Elixir: Higher-level abstractions and built-in libraries result in faster development cycles for complex applications. C: Lower-level control requires more code and a deeper understanding of the system, leading to longer development times for complex tasks. TIP Elixir is ideal for building distributed, fault-tolerant systems and web applications, leveraging concurrency and scalability. C, on the other hand, is unparalleled in scenarios demanding direct hardware control, performance optimization, or embedded system development. The choice between Elixir and C depends on the specific requirements of the application, such as performance needs, system complexity, and fault tolerance. 1.2 Getting Started To run Elixir on Ubuntu, follow these steps to install and get started: 1. Install Elixir First, ensure your system is up-to-date: sudo apt-get update install Elixir: sudo apt-get install -y elixir 2. Verify Installation After installation, check if Elixir was installed correctly: elixir -v This command should display the installed version of Elixir. 3. Running Elixir Code You can run Elixir in several ways: 3.1 Interactive Elixir (IEx) To start an interactive Elixir shell, run: iex In the iex shell, you can enter Elixir code and get immediate feedback: iex&gt; IO.puts(\"Hello, World!\") Hello, World! :ok 3.2 Running a Script Create a file named example.exs: nano example.exs Add the following Elixir code: IO.puts(\"Hello, Elixir!\") Save and exit. Then run the script with: elixir example.exs You should see: Hello, Elixir! 1.3 Data Structures in Elixir In Elixir, data structures and control structures are designed to work harmoniously with its functional programming paradigm. Here’s an overview along with examples: 1. Tuples: Tuples are fixed-size collections of values. They are often used to group related values. Example: person = {\"John\", 30, :male} IO.puts elem(person, 1) # Outputs: 30 2. Lists: Lists are linked lists, which means they are efficient for prepending elements but can be slow for indexing. Example: fruits = [\"apple\", \"banana\", \"cherry\"] IO.puts hd(fruits) # Outputs: apple 3. Maps: Maps are key-value stores, useful when you need to associate keys with values. Example: person = %{\"name\" =&gt; \"John\", \"age\" =&gt; 30} IO.puts person[\"name\"] # Outputs: John 4. Keyword Lists: A special list of tuples where the first element is an atom. Often used for options. Example: options = [width: 200, height: 100] IO.puts options[:width] # Outputs: 200 5. Structs: Structs are special maps with a fixed set of keys and default values, used to create custom data types. Example: defmodule Person do defstruct name: \"John\", age: 30 end person = %Person{name: \"Alice\"} IO.puts person.name # Outputs: Alice 6. Binaries and Strings: Binaries are sequences of bytes, and strings are UTF-8 encoded binaries. Example: binary = &lt;&lt;104, 101, 108, 108, 111&gt;&gt; # \"hello\" in binary IO.puts binary # Outputs: hello 1.4 Control Structures in Elixir 1. if/else: Conditional execution based on a boolean value. Example: age = 18 if age &gt;= 18 do IO.puts \"Adult\" else IO.puts \"Minor\" end 2. unless/else: The opposite of if, it executes the block if the condition is false. Example: unless is_nil(nil) do IO.puts \"Not nil\" else IO.puts \"Is nil\" end 3. case: Pattern matching against multiple possible values. Example: case {1, 2, 3} do {1, x, 3} -&gt; IO.puts \"Matched with x = #{x}\" _ -&gt; IO.puts \"No match\" end 4. cond: Similar to if/else, but evaluates multiple conditions. Example: cond do 2 + 2 == 5 -&gt; \"Math is wrong\" 2 + 2 == 4 -&gt; IO.puts \"Math is correct\" true -&gt; \"Default\" end 5. with: Used to chain pattern matches that depend on each other, often for more readable code. Example: with {:ok, data} &lt;- fetch_data(), {:ok, processed} &lt;- process_data(data) do IO.puts \"Success\" else _ -&gt; IO.puts \"Failure\" end TIP Data Structures: Tuples, Lists, Maps, Keyword Lists, Structs, Binaries/Strings. Control Structures: if/else, unless/else, case, cond, with. Elixir’s data structures are designed for immutability, and its control structures are pattern matching-centric, enabling concise and powerful ways to handle logic. 1.5 Data Structure - Tuple Tuples in Elixir are versatile data structures that can store a fixed number of elements. Here are some additional examples to illustrate their usage: 1. Basic Tuple A tuple can hold different data types, such as integers, strings, atoms, or other tuples. Example: coordinates = {40.7128, -74.0060} # Tuple representing latitude and longitude IO.puts elem(coordinates, 0) # Outputs: 40.7128 IO.puts elem(coordinates, 1) # Outputs: -74.0060 2. Pattern Matching with Tuples You can use pattern matching to destructure tuples and extract their values. Example: {x, y} = {10, 20} IO.puts x # Outputs: 10 IO.puts y # Outputs: 20 3. Returning Multiple Values from a Function Tuples are often used to return multiple values from a function. Example: defmodule Math do def add_and_subtract(a, b) do {a + b, a - b} end end {sum, difference} = Math.add_and_subtract(10, 4) IO.puts sum # Outputs: 14 IO.puts difference # Outputs: 6 4. Tagged Tuples A common pattern in Elixir is using a tuple where the first element is an atom that “tags” the data (often used for success/error handling). Example: {:ok, result} = {:ok, 42} IO.puts result # Outputs: 42 {:error, message} = {:error, \"Something went wrong\"} IO.puts message # Outputs: Something went wrong 5. Storing Related Data Tuples can store related data together, like a mini-record. Example: person = {\"John\", 30, :developer} IO.puts \"Name: #{elem(person, 0)}\" IO.puts \"Age: #{elem(person, 1)}\" IO.puts \"Occupation: #{elem(person, 2)}\" 6. Nested Tuples Tuples can contain other tuples, which is useful for organizing complex data. Example: nested_tuple = { {1, 2}, {3, 4}, {5, 6} } IO.inspect elem(nested_tuple, 1) # Outputs: {3, 4} 7. Updating Tuples Tuples are immutable, so to “update” a tuple, you create a new one with the desired changes. Example: tuple = {1, 2, 3} new_tuple = put_elem(tuple, 1, 42) IO.inspect new_tuple # Outputs: {1, 42, 3} 8. Tuple Size You can check the size of a tuple using tuple_size/1. Example: tuple = {:apple, :banana, :cherry} IO.puts tuple_size(tuple) # Outputs: 3 TIP Tuples are versatile in Elixir, useful for pattern matching, returning multiple values, and organizing related data. They are immutable and can hold elements of any data type, including other tuples. 1.6 Data Structure - List Lists in Elixir are fundamental data structures that are commonly used for storing collections of elements. Here are some examples to showcase how you can work with lists: 1. Creating and Accessing Lists Lists are defined using square brackets, and elements can be accessed using the hd/1 (head) and tl/1 (tail) functions. Example: fruits = [\"apple\", \"banana\", \"cherry\"] IO.puts hd(fruits) # Outputs: apple (head of the list) IO.inspect tl(fruits) # Outputs: [\"banana\", \"cherry\"] (tail of the list) 2. Concatenating Lists You can concatenate lists using the ++/2 operator. Example: list1 = [1, 2, 3] list2 = [4, 5, 6] combined = list1 ++ list2 IO.inspect combined # Outputs: [1, 2, 3, 4, 5, 6] 3. Subtracting Lists Use the --/2 operator to remove elements from a list. Example: numbers = [1, 2, 3, 4, 5] filtered = numbers -- [2, 4] IO.inspect filtered # Outputs: [1, 3, 5] 4. Pattern Matching with Lists You can destructure lists using pattern matching. Example: [head | tail] = [10, 20, 30, 40] IO.puts head # Outputs: 10 IO.inspect tail # Outputs: [20, 30, 40] 5. Recursively Processing Lists Lists are commonly processed recursively in Elixir. Example: Summing all elements in a list. defmodule Math do def sum([]), do: 0 def sum([head | tail]), do: head + sum(tail) end IO.puts Math.sum([1, 2, 3, 4]) # Outputs: 10 6. List Comprehensions List comprehensions provide a concise way to generate lists or perform operations on lists. Example: Doubling each element in a list. numbers = [1, 2, 3, 4] doubled = for n &lt;- numbers, do: n * 2 IO.inspect doubled # Outputs: [2, 4, 6, 8] 7. Filtering Lists You can filter lists based on a condition using list comprehensions. Example: Filtering even numbers. numbers = [1, 2, 3, 4, 5, 6] evens = for n &lt;- numbers, rem(n, 2) == 0, do: n IO.inspect evens # Outputs: [2, 4, 6] 8. Appending Elements to a List Since lists are linked lists, appending elements to the end requires creating a new list. Example: list = [1, 2, 3] new_list = list ++ [4] IO.inspect new_list # Outputs: [1, 2, 3, 4] 9. Reversing a List You can reverse a list using the Enum.reverse/1 function. Example: list = [1, 2, 3] reversed = Enum.reverse(list) IO.inspect reversed # Outputs: [3, 2, 1] 10. Finding the Length of a List Use the length/1 function to determine the number of elements in a list. Example: list = [\"apple\", \"banana\", \"cherry\"] IO.puts length(list) # Outputs: 3 11. Inserting an Element at the Beginning of a List Prepending an element to a list is efficient and straightforward using the | operator. Example: list = [2, 3, 4] new_list = [1 | list] IO.inspect new_list # Outputs: [1, 2, 3, 4] 12. Checking if a List is Empty You can check if a list is empty by pattern matching or using the == operator. Example: empty_list = [] IO.puts length(empty_list) == 0 # Outputs: true IO.puts empty_list == [] # Outputs: true TIP Elixir lists are versatile and are well-suited for functional programming, offering features such as efficient prepending, pattern matching, and recursion. They are fundamental to many Elixir programs, and understanding how to manipulate lists is key to writing effective Elixir code. 1.7 Control Structure - Loops Elixir uses recursion or higher-order functions like Enum and Stream instead of traditional loops. Here’s an example using Enum.each to loop through a list: Enum.each([1, 2, 3, 4, 5], fn x -&gt; IO.puts(\"Number: #{x}\") end) This code loops through the list [1, 2, 3, 4, 5] and prints each number. You can also use recursion: defmodule LoopExample do def print_numbers([]), do: :ok def print_numbers([head | tail]) do IO.puts(\"Number: #{head}\") print_numbers(tail) end end LoopExample.print_numbers([1, 2, 3, 4, 5]) This recursive function achieves the same result. 1.8 Functions 1. Writing a simple Function In Elixir, functions can be defined inside a module. Here’s a basic example of how to write a function: defmodule MyModule do def greet(name) do \"Hello, #{name}!\" end end defmodule MyModule do: Defines a module named MyModule. def greet(name) do: Defines a function greet that takes one argument, name. \"Hello, #{name}!\": Returns a greeting string. end: Closes the function and module. You can call the function like this: MyModule.greet(\"Alice\") # Returns \"Hello, Alice!\" Elixir functions can also be written in a one-liner if they are simple: defmodule MyModule do def greet(name), do: \"Hello, #{name}!\" end Function that returns no value In Elixir, a function that returns no meaningful value usually returns the atom :ok or :nil. Here’s an example: defmodule MyModule do def log_message(message) do IO.puts(\"Logging: #{message}\") :ok end end log_message/1 prints a message to the console using IO.puts/1 and then returns :ok. The function doesn’t return a value that’s meant to be used elsewhere, so :ok is used to signify successful completion. You can call this function like so: MyModule.log_message(\"Engine started\") # Outputs \"Logging: Engine started\" and returns :ok 2. Function name and Arity In Elixir (and other functional programming languages), the terms arity and function name are essential concepts for understanding how functions work. 2.1 Function Name The function name is simply the identifier you give to a function. It is what you use to call the function in your code. Example: defmodule Math do def add(a, b) do a + b end end In this example, add is the function name. 2.2 Arity Arity refers to the number of arguments a function takes. It is an integral part of how functions are identified in Elixir. Functions with the same name but different arities are treated as different functions. In Elixir, the arity is often explicitly mentioned alongside the function name, such as add/2, where 2 indicates that the function takes two arguments. Examples: 1. Single Arity Function: defmodule Greeter do def hello(name) do \"Hello, \" &lt;&gt; name end end The function hello/1 has an arity of 1 because it takes one argument. 2. Multiple Functions with Different Arities: defmodule Math do def add(a, b) do a + b end def add(a, b, c) do a + b + c end end Here, add/2 and add/3 are two different functions with different arities. The first takes two arguments, and the second takes three. Why is Arity Important? Function Identification: In Elixir, functions are uniquely identified by both their name and their arity. This allows you to define multiple functions with the same name but different numbers of arguments. Pattern Matching: Arity is essential when using pattern matching. Functions with different arities can have different behavior based on the number of arguments provided. TIP Function name is the identifier used to call a function. Arity refers to the number of arguments a function takes. In Elixir, functions are uniquely identified by their name and arity, such as add/2 or add/3. 3. Help on Functions In Elixir, you can get help or documentation for a function using the h helper in an interactive Elixir shell (IEx). The h command provides detailed information about the function, including its purpose, arguments, and examples. 3.1 Steps to Get Help for a Function in Elixir: 1. Start IEx: Open your terminal and start the interactive Elixir shell by typing: iex 2. Use the h Helper: To get help for a specific function, use the h helper followed by the module name and the function name, along with its arity. For example: h Enum.map/2 This command will display the documentation for the Enum.map/2 function. 3.2 Example in IEx: iex&gt; h Enum.map/2 def map(enumerable, fun) Returns a new enumerable where each item is the result of invoking `fun` on each corresponding item of `enumerable`. ## Examples iex&gt; Enum.map([1, 2, 3], fn x -&gt; x * 2 end) [2, 4, 6] 3.3 Additional Tips: If you need help with all the functions in a module, you can type h ModuleName: h Enum To get help on Elixir’s operators or other special constructs, you can use h with the operator: h Kernel.+/2 1.9 Pipe Operator The |&gt; operator in Elixir is known as the pipe operator. It is used to pass the result of one function as the first argument to the next function in a chain, creating a more readable and concise flow of data through multiple functions. 1. How the Pipe Operator Works The expression on the left side of the |&gt; operator is passed as the first argument to the function on the right side. This allows for a clean and natural flow, especially when chaining multiple function calls. 2. Simple Example Here’s a basic example using the pipe operator to manipulate a list: # Without the pipe operator list = [1, 2, 3, 4] result = Enum.map(list, fn x -&gt; x * 2 end) final_result = Enum.filter(result, fn x -&gt; x &gt; 4 end) IO.inspect(final_result) # Outputs: [6, 8] # Using the pipe operator final_result = [1, 2, 3, 4] |&gt; Enum.map(fn x -&gt; x * 2 end) |&gt; Enum.filter(fn x -&gt; x &gt; 4 end) IO.inspect(final_result) # Outputs: [6, 8] 3. Explanation Without the pipe operator: The result of each function must be stored in a variable before passing it to the next function, which can lead to nested or repetitive code. With the pipe operator: The flow is more readable and intuitive. The list [1, 2, 3, 4] is passed through the Enum.map/2 function, and its result is automatically passed to Enum.filter/2. 4. Additional Example Using the pipe operator to transform a string: result = \"elixir is awesome\" |&gt; String.upcase() |&gt; String.split(\" \") |&gt; Enum.join(\"-\") IO.puts(result) # Outputs: ELIXIR-IS-AWESOME TIP The |&gt; operator in Elixir simplifies chaining function calls by passing the result of one function as the first argument to the next. It improves code readability and reduces the need for intermediate variables."
  },"/cs/lang_pl/functional/1_elixir_2_extended_example/": {
    "title": "2. Extended Examples",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/1_elixir_2_extended_example/",
    "body": "2.1 Example 01 You are designing a system that monitors and regulates the turbine inlet temperature, oil temperature, and oil pressure for an aircraft engine. Every cycle a new reading is taken and appended to a list such as the following: [851, 841, 800, 756, 640, 390, 201] … where the head of the list is the latest reading taken. The componet you are building is tasked in monitoring for anomalous spikes or drops that may indicate mechanical failure. You may assume all readings are integers. Q1: Latest Reading Implement EngineMonitor.latest/1 such that it returns the last reading taken from a given list. Here’s how you can implement EngineMonitor.latest/1 in Elixir to return the last reading taken from a given list: defmodule EngineMonitor do def latest([latest | _rest]), do: latest end Given a list, this function extracts and returns the head, which is the latest reading. For example: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.latest(readings) # returns 851 Q2: Max Reading EngineMonitor.max_reading/1 returns the maximum reading from a list: defmodule EngineMonitor do def max_reading(readings) do Enum.max(readings) end end Enum.max/1 finds the maximum value in the readings list. The function returns the highest integer from the list. Example Usage: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.max_reading(readings) # Returns 851 - Using Recursion: To implement EngineMonitor.max_reading/1 without using Enum, you can use recursion to find the maximum value in a list. Here’s how you can do it: defmodule EngineMonitor do def max_reading([head | tail]) do max_reading(tail, head) end defp max_reading([], max), do: max defp max_reading([head | tail], max) do new_max = if head &gt; max, do: head, else: max max_reading(tail, new_max) end end 1. max_reading([head | tail]): Starts the recursion with the first element of the list as the initial maximum value. 2. max_reading([], max): Base case, returns the maximum value when the list is empty. 3. max_reading([head | tail], max): Recursive case, updates the maximum value if the current element is greater, then proceeds with the rest of the list. Example Usage: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.max_reading(readings) # Returns 851 Q3: Rising Reading EngineMonitor.rising/1 returns the number of times a reading has risen in a given list, you can compare each element with the next one and count how many times the reading increases. defmodule EngineMonitor do def rising(readings) do readings |&gt; Enum.chunk_every(2, 1, :discard) |&gt; Enum.count(fn [a, b] -&gt; b &gt; a end) end end Enum.chunk_every(2, 1, :discard): Splits the list into overlapping pairs. Enum.count(fn [a, b] -&gt; b &gt; a end): Counts how many pairs have a rising trend. Example Usage: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.rising(readings) # Returns 0 readings = [200, 300, 250, 400, 450] EngineMonitor.rising(readings) # Returns 3 This implementation counts how many times a reading has increased compared to the previous one. Q4: Danger Reading EngineMonitor.danger?/1 returns true if a dangerous spike or drop in readings (a change of 50 or more) is detected, you can compare consecutive readings and check if the difference between them is 50 or greater. defmodule EngineMonitor do def danger?(readings) do readings |&gt; Enum.chunk_every(2, 1, :discard) |&gt; Enum.any?(fn [a, b] -&gt; abs(a - b) &gt;= 50 end) end end Enum.chunk_every(2, 1, :discard): Creates overlapping pairs of consecutive readings. Enum.any?(fn [a, b] -&gt; abs(a - b) &gt;= 50 end): Checks if any pair has an absolute difference of 50 or more. Example Usage: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.danger?(readings) # Returns true (640 -&gt; 390 is a drop of 250) readings = [200, 220, 230, 240, 245] EngineMonitor.danger?(readings) # Returns false (no spike or drop of 50 or more) This implementation correctly identifies hazardous conditions based on the defined threshold. - Using Recursion To implement EngineMonitor.danger?/1 without using Enum, you can use recursion to check for dangerous spikes or drops. Here’s how you can do it: defmodule EngineMonitor do def danger?(readings) do check_danger(readings, nil) end defp check_danger([], _previous), do: false defp check_danger([current | rest], nil) do check_danger(rest, current) end defp check_danger([current | rest], previous) do if abs(current - previous) &gt;= 50 do true else check_danger(rest, current) end end end 1. danger?(readings): Starts the recursion by calling check_danger/2 with an initial value of nil for the previous reading. 2. check_danger([], _previous): Base case, returns false when the list is empty (no dangerous changes found). 3. check_danger([current | rest], nil): When starting with the first element, there’s no previous reading to compare to. Continue with the rest of the list. 4. check_danger([current | rest], previous): Compares the current reading with the previous one. If the absolute difference is 50 or more, return true. Otherwise, continue checking the rest of the list. Example Usage: readings = [851, 841, 800, 756, 640, 390, 201] EngineMonitor.danger?(readings) # Returns true (640 -&gt; 390 is a drop of 250) readings = [200, 220, 230, 240, 245] EngineMonitor.danger?(readings) # Returns false (no spike or drop of 50 or more) This implementation uses recursion to traverse the list and identify any dangerous changes based on the specified threshold. Q5: Fire Reading EngineMonitor.fire?/1 detects whether the word “FIRE” appears in a string regardless of case, you can use String.downcase/1 to convert the string to lowercase and then check for the presence of the lowercase equivalent of “FIRE”. defmodule EngineMonitor do def fire?(text) do String.contains?(String.downcase(text), \"fire\") end end 1. String.downcase(text): Converts the entire input string to lowercase. 2. String.contains?(string, \"fire\"): Checks if the lowercase string contains the substring \"fire\". Example Usage: EngineMonitor.fire?(\"The alarm system detected a FIRE\") # Returns true EngineMonitor.fire?(\"No fire detected\") # Returns true EngineMonitor.fire?(\"Just a test\") # Returns false This implementation ensures that the check for the word “FIRE” is case-insensitive."
  },"/cs/lang_pl/functional/2_scheme_1_basics/": {
    "title": "1. Basics",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/2_scheme_1_basics/",
    "body": "2.1 Background 1. Comparing Functional Programming Languages (FPLs) to Other Languages Functional Programming Languages (FPLs): FPLs like Haskell and Scheme emphasize functions as first-class citizens, immutability, and referential transparency. Functions are pure, meaning they don’t have side effects and their output is solely determined by their input. Imperative Languages: Languages like C and Java focus on changing state through statements and commands. They often rely on mutable data and have side effects. The focus is on the sequence of operations to achieve a result. Object-Oriented Languages: Languages like Python and Java incorporate encapsulation, inheritance, and polymorphism. They blend functional and imperative styles, allowing mutable state and side effects, but also support functions and methods. 2. Referential Transparency: Referential transparency means that an expression can be replaced with its value without changing the program’s behavior. This is a key property of pure functions in FPLs. Example: In a function f(x) = x + 2, you can replace f(3) with 5 because f(3) always evaluates to 5 given x is 3. 3. Side Effects: A side effect is any change in state or observable interaction with the outside world that occurs during the execution of a function. This includes modifying a global variable, writing to a file, or printing to the console. In FPLs: Traditional FPLs avoid side effects by using pure functions. However, some FPLs allow controlled side effects, for example, in Haskell, through the IO monad. 4. Functions as Values in FPLs Yes, functions can be treated as values in FPLs. They can be passed as arguments to other functions, returned as results, and assigned to variables. 5. Suitability of FPLs for Concurrent Systems FPLs are often suitable for concurrent systems due to their emphasis on immutability and stateless functions. These characteristics help avoid issues related to shared mutable state and make it easier to reason about concurrent execution. Example: Languages like Erlang and Elixir (based on the Erlang VM) use functional paradigms to manage concurrency and are designed to handle many concurrent processes efficiently. 6. Tail Recursion Optimization (TRO) Tail recursion optimization is a technique where the compiler or interpreter optimizes tail-recursive functions to avoid growing the call stack. In a tail-recursive function, the recursive call is the last operation in the function. Example: The tail-recursive version of a factorial function avoids stack overflow issues by reusing the current function’s stack frame. 7. Lambda Functions Lambda functions are anonymous functions that are defined inline without a name. They are often used for short-lived, simple operations. Example in Python: lambda x: x + 1 is a lambda function that adds 1 to its argument. 8. Closure A closure is a function that captures the lexical environment in which it was defined, allowing it to access variables from that scope even after the outer function has finished executing. Example in JavaScript: function outer() { let x = 10; return function inner() { console.log(x); }; } let closure = outer(); closure(); // Logs 10 9. Comparing Scheme and Elixir Scheme: A minimalist, functional Lisp dialect that emphasizes recursion and symbolic computation. It’s known for its simplicity and powerful macro system. Elixir: A functional language designed for concurrent, distributed systems. It runs on the Erlang VM and focuses on fault tolerance and scalability. Elixir has immutable data structures and a message-passing concurrency model. Lisp and Scheme Lisp (short for “LISt Processing”) is a family of programming languages that has a long history in computer science, dating back to its creation by John McCarthy in 1958. Lisp is known for its simple and powerful syntax, where code and data share the same structure (both are represented as lists). This feature, called “homoiconicity,” allows Lisp programs to easily manipulate code as data, making it a popular choice for symbolic computation, AI research, and academic exploration. Scheme is a dialect of Lisp, created in the 1970s by Guy L. Steele and Gerald Jay Sussman. Scheme was designed to be a simpler, more elegant, and minimalistic version of Lisp, emphasizing a small core of powerful features and a clean, consistent design. It introduced several key ideas to the Lisp family, such as first-class continuations and lexical scoping, which influenced many later programming languages. TIP Lisp: A family of programming languages with a long history, known for its list-based syntax and powerful code-as-data capabilities. Scheme: A minimalist dialect of Lisp that emphasizes simplicity, elegance, and a small set of powerful features. 10. Orthogonality in Scheme Scheme is considered orthogonal because its features are independent and can be combined in a modular way. For example, functions and conditionals can be combined without restrictions. - **Example**: You can use functions and conditionals together: ```scheme (define (max a b) (if (&gt; a b) a b)) ``` 11. List Structures in Elixir and Scheme Both languages use lists as fundamental data structures. - **Scheme**: ```scheme (define my-list (list 1 2 3)) ``` - **Elixir**: ```elixir my_list = [1, 2, 3] ``` 12. Scheme’s car and cdr Functions - **`car`**: Returns the first element of a list. ```scheme (car (list 1 2 3)) ; Returns 1 ``` - **`cdr`**: Returns the rest of the list after removing the first element. ```scheme (cdr (list 1 2 3)) ; Returns (2 3) ``` 13. Tail-Recursive Factorial Function in Scheme To transform the given factorial function into a tail-recursive version: ```scheme (define (fact x) (define (fact-tail x acc) (if (= x 0) acc (fact-tail (- x 1) (* x acc)))) (fact-tail x 1)) ``` Here, `fact-tail` is the tail-recursive helper function, and `acc` accumulates the result. 1.2 What is an S-expression? An S-expression (symbolic expression) is a notation used in Lisp and its dialects to represent both code and data. It is a way to write nested lists using a simple parenthesis-based syntax. S-expressions are used to encode structured data and code in a uniform format. Basic Structure: Atoms: Basic elements that are indivisible, such as numbers, symbols (e.g., x, foo), or strings. Lists: Ordered sequences of S-expressions enclosed in parentheses. For example, (+ 1 2) is a list where + is the operator and 1 and 2 are operands. Example: (+ 1 2) is a list with the operator + and two operands 1 and 2. (define (square x) (* x x)) is a list representing a function definition. 1. Visually Representing S-expressions A visual representation of S-expressions often uses a tree structure where: Nodes: Represent individual elements or sub-expressions. Edges: Represent the hierarchical relationship between elements. Example Visualization: For the S-expression (+ 1 2), the tree representation is: + / \\ 1 2 For a more complex S-expression like (define (square x) (* x x)), the tree representation is: DEFINE / \\ SQUARE (* x x) / \\ / \\ x (* x x) / \\ x x 2. Evaluating S-expressions The evaluation of an S-expression in Lisp involves the following steps: 1. Check for Atom or List: If the S-expression is an atom, it is either a constant value or a variable. Constants evaluate to themselves, and variables are looked up in the environment. If the S-expression is a list, further evaluation is required. 2. Evaluate the Function Call: Function Name: The first element of the list is typically the function to be called. This element is evaluated to determine the actual function. Arguments: The remaining elements of the list are the arguments to the function. Each argument is evaluated in the current environment. 3. Apply the Function: After evaluating the function name and arguments, the function is applied to the arguments. The result of the function application is the result of the S-expression. Example Evaluation: Evaluate (+ 1 2): 1. Identify: + is a function, 1 and 2 are arguments. 2. Evaluate: + is the function that performs addition. 1 evaluates to 1. 2 evaluates to 2. 3. Apply: Perform the addition: 1 + 2 = 3. Another Example: Evaluate (define (square x) (* x x)): 1. Identify: define is a special form for defining functions. 2. Evaluate: square is the function name. x is the parameter. (* x x) is the body of the function. 3. Apply: In Lisp, this will define a function square that takes one argument x and returns (* x x). Thus, the evaluation process involves interpreting the list structure, applying functions, and using the results to compute the final value."
  },"/cs/lang_pl/functional/2_scheme_2_syntax/": {
    "title": "2. Syntax",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/2_scheme_2_syntax/",
    "body": "2.2 Simple Example To run a simple Scheme program in Ubuntu, you can use an interpreter like Gambit, MIT Scheme, or Racket. Here’s how you can do it using MIT Scheme: 1. Install MIT Scheme Open a terminal and run the following command to install MIT Scheme: sudo apt-get update sudo apt-get install mit-scheme 2. Write a Scheme Program Create a new file with a .scm extension (e.g., hello.scm). You can use any text editor, such as nano, vim, or gedit: nano hello.scm Write a simple Scheme program in the file: (display \"Hello, World!\") (newline) Save and exit the editor. 3. Run the Scheme Program You can run the program using the MIT Scheme interpreter: mit-scheme --load hello.scm This will execute the hello.scm file and display “Hello, World!” in the terminal. 4. Running in Interactive Mode Alternatively, you can start the MIT Scheme interpreter in interactive mode by typing: mit-scheme Once in the interactive mode, you can type and run Scheme code directly: (display \"Hello, World!\") (newline) To exit the interpreter, type: (exit) This setup should allow you to run simple Scheme programs on Ubuntu using MIT Scheme. 2.3 Control Structures Scheme, like other Lisp dialects, has a few core control structures for managing the flow of a program. Here are the most common ones: 1. Conditional Expressions 1.1 if The if expression is the basic conditional construct. Syntax: (if condition then-expression else-expression) (define x 10) (if (&gt; x 5) (display \"x is greater than 5\") (display \"x is not greater than 5\")) 1.2 cond The cond expression is used for multiple conditions, similar to a series of if-else statements. Syntax: (cond (condition1 expression1) (condition2 expression2) ... (else default-expression)) (define x 3) (cond ((= x 1) (display \"x is one\")) ((= x 2) (display \"x is two\")) ((= x 3) (display \"x is three\")) (else (display \"x is something else\"))) 2. Iteration 2.1 do The do expression is used for looping, with an initialization part, a termination condition, and a body that is executed repeatedly. Syntax: (do ((var init step) ...) (exit-condition result-expression) body ...) (do ((i 0 (+ i 1))) ((&gt;= i 5) (display \"Done\")) (display i) (newline)) This loop starts with i at 0 and increments it by 1 each time. The loop exits when i is 5 or greater. 2.2 let (used with recursion for iteration) Scheme often uses recursion for iteration, sometimes in combination with let for local variable binding. Syntax for named let (useful for creating loops): (let loop ((var1 init1) (var2 init2) ...) (if condition result (loop new-var1 new-var2 ...))) (let loop ((i 0)) (if (&lt; i 5) (begin (display i) (newline) (loop (+ i 1))))) This example mimics a for loop, incrementing i from 0 to 4. 3. Logical Operators and: Evaluates expressions from left to right and returns the first #f (false) value, or the last value if all are true. (if (and (&gt; 3 2) (&lt; 5 10)) (display \"True\") (display \"False\")) or: Evaluates expressions from left to right and returns the first non-#f (true) value, or #f if all are false. (if (or (&gt; 3 5) (&lt; 5 10)) (display \"True\") (display \"False\")) 4. Sequencing 4.1 begin The begin expression is used to sequence multiple expressions, where the expressions are evaluated in order and the value of the last expression is returned. Syntax: (begin expr1 expr2 ... exprN) (begin (display \"Hello, \") (display \"World!\") (newline)) These control structures are the building blocks for flow control in Scheme programs. 2.4 Data Structures In Scheme, data structures are often built using the language’s fundamental constructs like lists, pairs (cons cells), vectors, strings, and records. Here’s an overview of common data structures in Scheme: 1. Pairs and Lists 1.1 Pairs Scheme uses pairs (or cons cells) as a basic building block. A pair consists of two elements. cons creates a pair. car and cdr access the first and second elements of a pair, respectively. (define p (cons 1 2)) ; p is a pair containing 1 and 2 (car p) ; returns 1 (cdr p) ; returns 2 1.2 Lists A list is a sequence of elements, typically implemented as a chain of pairs. '() is the empty list. list creates a list of elements. (define lst (list 1 2 3 4)) ; lst is a list containing 1, 2, 3, 4 (car lst) ; returns 1 (cdr lst) ; returns (2 3 4) Nested Lists: Lists can contain other lists. (define nested-list (list 1 (list 2 3) 4)) ; nested-list is (1 (2 3) 4) 1.3 Difference between list and pairs In Scheme, both pairs and lists are fundamental data structures, but they serve different purposes and have distinct properties. Pairs Definition: A pair is a basic data structure consisting of two elements, often called car and cdr. It’s created using the cons procedure. Syntax: (cons x y) creates a pair where x is the car and y is the cdr. Usage: Pairs are used to build more complex structures, including lists and trees. They are flexible and can hold any type of data. Lists Definition: A list is a special case of pairs where the cdr of each pair is itself a list, ending in an empty list (). This recursive structure makes lists easy to process. Syntax: Lists are usually written using parentheses, e.g., (a b c d). Usage: Lists are used for ordered collections of items and are a common way to handle sequences of elements in Scheme. Why Two? Flexibility: Pairs offer a low-level building block that can be used to create various data structures beyond lists, like pairs, trees, and more. Lists provide a higher-level abstraction for ordered sequences. Efficiency: Working directly with pairs can be more efficient for certain operations or data structures, while lists offer convenient syntax and operations for working with sequences of elements. Abstraction: Lists abstract away the details of the underlying pairs, making it easier to work with sequences of data in a more readable and structured way. In essence, pairs provide the foundational building blocks, while lists offer a more specialized and user-friendly way to work with ordered collections. 2. Vectors Vectors are fixed-size, mutable arrays that allow constant-time access to elements. vector creates a vector. vector-ref accesses an element by index. vector-set! modifies an element. (define vec (vector 1 2 3 4)) ; vec is a vector containing 1, 2, 3, 4 (vector-ref vec 0) ; returns 1 (vector-set! vec 0 10) ; sets the first element to 10 3. Strings Strings are sequences of characters. string creates a string. string-ref accesses a character by index. string-set! modifies a character. (define str \"Hello, World!\") ; str is a string (string-ref str 0) ; returns #\\H 4. Records Records are structured data types with named fields. Scheme doesn’t have a standard built-in record type, but many implementations provide a way to define records (like define-record-type in Racket or SRFI-9). (define-record-type person (make-person name age) person? (name person-name) (age person-age)) (define p (make-person \"Alice\" 30)) (person-name p) ; returns \"Alice\" (person-age p) ; returns 30 5. Association Lists (Alists) An association list is a simple key-value store implemented as a list of pairs. assoc finds a key in an alist. (define alist '((a . 1) (b . 2) (c . 3))) (assoc 'b alist) ; returns (b . 2) 6. Hash Table Hash tables are available in many Scheme implementations and provide efficient key-value storage. Example using Racket: (define ht (make-hash)) (hash-set! ht 'key1 \"value1\") (hash-ref ht 'key1) ; returns \"value1\" 7. Queues and Stacks Queues and stacks can be implemented using lists, pairs, or vectors. 7.1 Stack (LIFO) (define stack '()) (define (push stack elem) (cons elem stack)) (define (pop stack) (cdr stack)) 7.2 Queue (FIFO) (define queue '()) (define (enqueue queue elem) (append queue (list elem))) (define (dequeue queue) (cdr queue)) TIP Pairs and Lists: Basic building blocks for many other data structures. Vectors: Mutable arrays with constant-time access. Strings: Sequences of characters. Records: Structured data types with named fields. Association Lists: Simple key-value pairs stored in lists. Hash Tables: Efficient key-value stores (available in some Scheme implementations). Queues and Stacks: Easily implemented using lists or pairs. These data structures cover most of the typical needs in Scheme programming, allowing for a wide range of algorithms and applications. 2.5 Functions In Scheme, functions are first-class citizens, and defining a function is straightforward. Here’s a basic overview of how to write a function in Scheme: 1. Defining a Function To define a function, you use the define keyword, followed by the function name, a list of parameters, and the function body. Syntax: (define (function-name parameter1 parameter2 ...) body-expressions) 2. Example 1: Simple Function Here’s a simple function that adds two numbers: (define (add a b) (+ a b)) define: This keyword defines a new function. add: This is the name of the function. a, b: These are parameters for the function. (+ a b): This is the body of the function, which returns the sum of a and b. Usage: (add 3 4) ; returns 7 3. Example 2: Recursive Function Here’s a function that calculates the factorial of a number recursively: (define (factorial n) (if (= n 0) 1 (* n (factorial (- n 1))))) factorial: This function calculates the factorial of n. if: Checks if n is 0; if true, returns 1 (base case). Otherwise, it multiplies n by the factorial of n-1. Usage: (factorial 5) ; returns 120 4. Example 3: Higher-Order Function Functions in Scheme can take other functions as arguments or return functions. Here’s an example of a higher-order function that takes a function and applies it twice: (define (apply-twice f x) (f (f x))) apply-twice: Takes a function f and an argument x, and applies f to x twice. Usage: (define (square x) (* x x)) (apply-twice square 2) ; returns 16 5. Lambda Expressions You can also define anonymous functions (lambda expressions) without naming them: (define (add-square x y) ((lambda (a b) (+ (* a a) (* b b))) x y)) Here, the lambda function takes two arguments and returns the sum of their squares. Usage: (add-square 3 4) ; returns 25 TIP define: Used to create named functions. lambda: Used to create anonymous functions. Function Body: Contains expressions that are evaluated when the function is called. Higher-Order Functions: Functions that take or return other functions. These are the basic steps to define and use functions in Scheme."
  },"/cs/lang_pl/functional/2_scheme_3_advance/": {
    "title": "2. Advance",
    "keywords": "functional",
    "url": "/cs/lang_pl/functional/2_scheme_3_advance/",
    "body": "2.1 Tree using pair data structure In Scheme, you can use pairs to build tree structures by defining each node in the tree as a pair. Here’s a basic approach to creating and manipulating binary trees using pairs: 1. Building a Binary Tree A binary tree node can be represented as a pair where: The car part holds the value of the node. The cdr part is itself a pair, where the car of this second pair is the left subtree and the cdr is the right subtree. Here’s how you might define a simple binary tree: (define (make-node value left right) (cons value (cons left right))) In this definition: value is the value of the current node. left is the left subtree (can be another node or () if there is no left child). right is the right subtree (can be another node or () if there is no right child). 2. Example Tree Consider a tree with the following structure: 1 / \\ 2 3 / \\ 4 5 You can represent this tree as follows: (define tree (make-node 1 (make-node 2 (make-node 4 '() '()) (make-node 5 '() '())) (make-node 3 '() '()))) 3. Accessing Tree Elements To access parts of the tree, you can use the car and cdr procedures: car of the tree gives the root value. cdr gives a pair where: car is the left subtree. cdr is the right subtree. For example: (define (root-value tree) (car tree)) (define (left-subtree tree) (car (cdr tree))) (define (right-subtree tree) (cdr (cdr tree))) 4. Traversing the Tree You can write recursive functions to traverse the tree. Here’s an example of an in-order traversal: (define (in-order-traversal tree) (if (null? tree) '() (append (in-order-traversal (left-subtree tree)) (list (root-value tree)) (in-order-traversal (right-subtree tree))))) TIP Using pairs to build trees in Scheme involves: Creating nodes: Each node is a pair with a value and two subtrees. Accessing parts: Use car and cdr to access the node’s value and its subtrees. Manipulating: Write recursive functions to traverse or modify the tree. This approach provides a flexible and powerful way to work with hierarchical data structures in Scheme."
  },"/cs/lang_pl/logical/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "logical",
    "url": "/cs/lang_pl/logical/1_basics/",
    "body": ""
  },"/cs/lang_pl/scripting/1_basics/": {
    "title": "1. Fundamentals",
    "keywords": "scripting",
    "url": "/cs/lang_pl/scripting/1_basics/",
    "body": ""
  }}
